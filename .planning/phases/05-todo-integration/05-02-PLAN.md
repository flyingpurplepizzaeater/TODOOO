---
phase: 05-todo-integration
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - frontend/src/services/todoApi.ts
  - frontend/src/components/Canvas/useTodoSync.ts
  - frontend/src/components/Canvas/Canvas.tsx
  - websocket.py
autonomous: true

must_haves:
  truths:
    - "Creating TODO on canvas creates TODO in backend"
    - "Updating TODO on canvas updates backend"
    - "Deleting TODO on canvas deletes from backend"
    - "Backend TODO changes push to canvas via WebSocket"
    - "Sync does not create echo loops"
  artifacts:
    - path: "frontend/src/services/todoApi.ts"
      provides: "Backend API client for TODOs"
      exports: ["createTodo", "updateTodo", "deleteTodo", "fetchTodo"]
    - path: "frontend/src/components/Canvas/useTodoSync.ts"
      provides: "Bidirectional sync hook"
      contains: "store.listen"
    - path: "websocket.py"
      provides: "TODO event broadcasting"
      contains: "todo_updated"
  key_links:
    - from: "frontend/src/components/Canvas/useTodoSync.ts"
      to: "todoApi.ts"
      via: "API calls on store changes"
      pattern: "createTodo|updateTodo|deleteTodo"
    - from: "frontend/src/components/Canvas/useTodoSync.ts"
      to: "editor.store"
      via: "store.listen and mergeRemoteChanges"
      pattern: "store\\.listen|mergeRemoteChanges"
    - from: "frontend/src/components/Canvas/Canvas.tsx"
      to: "useTodoSync"
      via: "hook invocation"
      pattern: "useTodoSync"
---

<objective>
Implement bidirectional sync between canvas TODO shapes and backend TODO API.

Purpose: Ensure TODO cards on canvas reflect backend state and vice versa. Creating, updating, or deleting TODOs on canvas syncs to backend. Backend changes (from other clients or API) push to canvas via WebSocket.

Output: todoApi service for REST calls, useTodoSync hook for bidirectional sync, WebSocket event handler for backend push updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-todo-integration/05-CONTEXT.md
@.planning/phases/05-todo-integration/05-RESEARCH.md
@.planning/phases/05-todo-integration/05-01-SUMMARY.md
@frontend/src/components/Canvas/Canvas.tsx
@frontend/src/components/Canvas/useYjsStore.ts
@routers/todos.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TODO API service</name>
  <files>
    frontend/src/services/todoApi.ts
  </files>
  <action>
Create `frontend/src/services/todoApi.ts`:

1. Import config for API base URL (use frontend/src/config.ts pattern if exists, else define BASE_URL)

2. Define TypeScript interfaces:
   ```typescript
   interface BackendTodoItem {
     id: number
     title: string
     description: string | null
     completed: boolean
     assigned_to: number | null
     assignee_username: string | null
     due_date: string | null  // ISO string
     list_id: number
     created_at: string
   }

   interface CreateTodoRequest {
     title: string
     description?: string
     assigned_to?: number
     due_date?: string
   }

   interface UpdateTodoRequest {
     title?: string
     description?: string
     completed?: boolean
     assigned_to?: number
     due_date?: string
   }
   ```

3. Implement API functions (all async, all require token):
   - `createTodo(listId: number, data: CreateTodoRequest, token: string): Promise<BackendTodoItem>`
     - POST /lists/{listId}/todos
   - `updateTodo(todoId: number, data: UpdateTodoRequest, token: string): Promise<BackendTodoItem>`
     - PUT /todos/{todoId}
   - `deleteTodo(todoId: number, token: string): Promise<void>`
     - DELETE /todos/{todoId}
   - `toggleTodo(todoId: number, token: string): Promise<BackendTodoItem>`
     - PATCH /todos/{todoId}/toggle
   - `fetchTodo(todoId: number, token: string): Promise<BackendTodoItem>`
     - GET (may need to add endpoint or fetch via list)
   - `fetchListTodos(listId: number, token: string): Promise<BackendTodoItem[]>`
     - GET /lists/{listId}/todos

4. Use fetch with proper headers:
   ```typescript
   headers: {
     'Content-Type': 'application/json',
     'Authorization': `Bearer ${token}`
   }
   ```

5. Handle errors: throw on non-2xx responses with message from response body.

Note: Backend API is at root (not /api prefix based on routers/todos.py).
  </action>
  <verify>
- File exists at `frontend/src/services/todoApi.ts`
- Exports createTodo, updateTodo, deleteTodo, toggleTodo functions
- Uses proper Authorization header with Bearer token
- TypeScript compiles: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>
API service provides typed functions for all TODO CRUD operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useTodoSync hook for canvas-to-backend sync</name>
  <files>
    frontend/src/components/Canvas/useTodoSync.ts
  </files>
  <action>
Create `frontend/src/components/Canvas/useTodoSync.ts`:

1. Import Editor from 'tldraw', TodoShape from shapes, and API functions

2. Hook signature:
   ```typescript
   export function useTodoSync(
     editor: Editor | null,
     token: string,
     defaultListId: number | null  // Which backend list to create TODOs in
   )
   ```

3. Canvas -> Backend sync using store.listen:
   ```typescript
   useEffect(() => {
     if (!editor || !defaultListId) return

     const unsub = editor.store.listen(
       ({ changes }) => {
         // Handle added TODO shapes
         Object.values(changes.added).forEach(record => {
           if (record.typeName === 'shape' && (record as any).type === 'todo') {
             const todo = record as TodoShape
             if (!todo.props.backendId) {
               // New TODO - create in backend
               handleCreate(todo)
             }
           }
         })

         // Handle updated TODO shapes
         Object.values(changes.updated).forEach(([from, to]) => {
           if (to.typeName === 'shape' && (to as any).type === 'todo') {
             const todo = to as TodoShape
             if (todo.props.backendId) {
               handleUpdate(todo)
             }
           }
         })

         // Handle removed TODO shapes
         Object.values(changes.removed).forEach(record => {
           if (record.typeName === 'shape' && (record as any).type === 'todo') {
             const todo = record as TodoShape
             if (todo.props.backendId) {
               handleDelete(todo.props.backendId)
             }
           }
         })
       },
       { source: 'user', scope: 'document' }  // CRITICAL: source:'user' prevents echo loop
     )

     return () => unsub()
   }, [editor, token, defaultListId])
   ```

4. Implement handler functions:
   - handleCreate: Call createTodo, then update shape with backendId using editor.updateShape
   - handleUpdate: Call updateTodo (debounce with 500ms to prevent excessive calls)
   - handleDelete: Call deleteTodo

5. Use lodash debounce for update calls (install if needed or use simple timeout)

6. Error handling: Log errors, don't crash - user can retry

CRITICAL: Always use { source: 'user' } to prevent echo loops per RESEARCH.md pitfall #1.
  </action>
  <verify>
- File exists at `frontend/src/components/Canvas/useTodoSync.ts`
- Uses store.listen with { source: 'user' } filter
- Handles added, updated, removed changes
- Calls API functions for CRUD operations
- TypeScript compiles: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>
Canvas changes sync to backend API with echo loop prevention.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add backend-to-canvas sync via WebSocket events</name>
  <files>
    frontend/src/components/Canvas/useTodoSync.ts
    websocket.py
  </files>
  <action>
1. Extend useTodoSync to handle incoming WebSocket events:

   Add WebSocket listener for TODO events:
   ```typescript
   // Backend -> Canvas sync
   useEffect(() => {
     if (!editor) return

     // Listen for custom TODO events on the WebSocket
     // Assuming events come through existing Yjs provider or separate channel
     const handleTodoEvent = (event: CustomEvent<TodoWebSocketEvent>) => {
       const { type, data } = event.detail

       editor.store.mergeRemoteChanges(() => {
         switch (type) {
           case 'todo_updated': {
             // Find shape with this backendId and update
             const shapes = editor.getCurrentPageShapes()
             const todoShape = shapes.find(
               s => s.type === 'todo' && (s as TodoShape).props.backendId === data.id
             )
             if (todoShape) {
               editor.updateShape({
                 id: todoShape.id,
                 type: 'todo',
                 props: {
                   title: data.title,
                   completed: data.completed,
                   dueDate: data.due_date,
                   assigneeId: data.assigned_to,
                   assigneeName: data.assignee_username,
                 }
               })
             }
             break
           }
           case 'todo_deleted': {
             const shapes = editor.getCurrentPageShapes()
             const todoShape = shapes.find(
               s => s.type === 'todo' && (s as TodoShape).props.backendId === data.id
             )
             if (todoShape) {
               editor.deleteShape(todoShape.id)
             }
             break
           }
         }
       })  // mergeRemoteChanges wraps update to mark as remote
     }

     window.addEventListener('todo-sync', handleTodoEvent as EventListener)
     return () => window.removeEventListener('todo-sync', handleTodoEvent as EventListener)
   }, [editor])
   ```

2. Update websocket.py to broadcast TODO events:

   Add TODO event broadcasting function:
   ```python
   async def broadcast_todo_event(board_id: str, event_type: str, todo_data: dict):
       """Broadcast TODO changes to all connected clients for a board."""
       # This will dispatch to connected WebSocket clients
       # Implementation depends on existing WebSocket architecture
       pass
   ```

   Note: The existing WebSocket uses pycrdt-websocket for Yjs sync. TODO events may need:
   - Option A: Piggyback on Yjs awareness protocol
   - Option B: Separate WebSocket endpoint for app events
   - Option C: Use Yjs Y.Map for TODO events (not recommended - mixing concerns)

   For now, implement a simple event dispatcher that can be called from TODO routers.
   The frontend will listen via CustomEvent on window.

3. CRITICAL: All updates inside mergeRemoteChanges() to prevent echo loops.
  </action>
  <verify>
- useTodoSync handles 'todo-sync' CustomEvent
- Updates inside mergeRemoteChanges wrapper
- websocket.py has broadcast_todo_event function (even if stub for now)
- No circular sync: source:'user' on listen, mergeRemoteChanges on receive
  </verify>
  <done>
Backend changes can push to canvas, bidirectional sync architecture complete.
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate useTodoSync in Canvas component</name>
  <files>
    frontend/src/components/Canvas/Canvas.tsx
  </files>
  <action>
1. Import useTodoSync hook

2. Add listId prop to CanvasProps (or use a sensible default/context):
   ```typescript
   interface CanvasProps {
     boardId: string
     token: string
     defaultListId?: number  // Backend list for new TODOs
   }
   ```

3. Call useTodoSync in Canvas component:
   ```typescript
   // Store editor reference for sync hook
   const [editor, setEditor] = useState<Editor | null>(null)

   // Enable TODO sync when editor is ready
   useTodoSync(editor, token, defaultListId ?? null)

   // Update handleMount to set editor
   const handleMount = useCallback((ed: Editor) => {
     setEditor(ed)
     editorRef.current = ed
     // ... rest of existing mount logic
   }, [])
   ```

4. Note: defaultListId could come from:
   - Props passed from parent
   - Board metadata (future enhancement)
   - First list in team (future enhancement)

   For now, make it optional and skip sync if not provided.
  </action>
  <verify>
- Canvas.tsx imports and calls useTodoSync
- CanvasProps includes optional defaultListId
- Editor state set on mount for sync hook
- TypeScript compiles: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>
Canvas component wired up with TODO sync, CRUD operations sync to backend when listId provided.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compilation:
   ```bash
   cd frontend && npx tsc --noEmit
   ```

2. File structure check:
   - frontend/src/services/todoApi.ts exists
   - frontend/src/components/Canvas/useTodoSync.ts exists

3. Sync architecture check:
   - store.listen uses { source: 'user' }
   - Backend updates use mergeRemoteChanges()
   - No direct API calls inside mergeRemoteChanges

4. Code pattern check:
   - useTodoSync imported in Canvas.tsx
   - Editor reference passed to sync hook
</verification>

<success_criteria>
1. todoApi.ts provides createTodo, updateTodo, deleteTodo, toggleTodo functions
2. useTodoSync hook listens to store changes with source:'user' filter
3. Creating TODO shape calls createTodo API and updates shape with backendId
4. Updating TODO shape calls updateTodo API (debounced)
5. Deleting TODO shape calls deleteTodo API
6. Backend events wrapped in mergeRemoteChanges to prevent echo
7. Canvas.tsx integrates useTodoSync hook
8. All TypeScript compiles without new errors
</success_criteria>

<output>
After completion, create `.planning/phases/05-todo-integration/05-02-SUMMARY.md`
</output>
