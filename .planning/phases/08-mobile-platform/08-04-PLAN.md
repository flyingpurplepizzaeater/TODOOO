---
phase: 08-mobile-platform
plan: 04
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - frontend/src/capacitor/camera.ts
  - frontend/src/capacitor/notifications.ts
  - frontend/src/capacitor/exports.ts
  - frontend/src/capacitor/index.ts
  - frontend/src/components/Canvas/CustomToolbar.tsx
  - frontend/ios/App/App/Info.plist
  - frontend/android/app/src/main/AndroidManifest.xml
autonomous: true

must_haves:
  truths:
    - "User can capture photo and add it to canvas"
    - "User can schedule TODO reminder notifications"
    - "User can export board to Photos app"
    - "User can export board to Files app"
    - "Camera permission prompt works on iOS and Android"
  artifacts:
    - path: "frontend/src/capacitor/camera.ts"
      provides: "Camera capture service"
      exports: ["capturePhotoToCanvas"]
    - path: "frontend/src/capacitor/notifications.ts"
      provides: "TODO reminder service"
      exports: ["scheduleTodoReminder", "cancelTodoReminder"]
    - path: "frontend/src/capacitor/exports.ts"
      provides: "Export to Photos/Files service"
      exports: ["exportToPhotos", "exportToFiles"]
    - path: "frontend/ios/App/App/Info.plist"
      provides: "iOS permission descriptions"
      contains: "NSCameraUsageDescription"
    - path: "frontend/android/app/src/main/AndroidManifest.xml"
      provides: "Android permissions"
      contains: "android.permission.CAMERA"
  key_links:
    - from: "frontend/src/components/Canvas/CustomToolbar.tsx"
      to: "frontend/src/capacitor/camera.ts"
      via: "camera button click handler"
      pattern: "capturePhotoToCanvas"
---

<objective>
Implement native mobile features: camera capture, push notifications, and export to Photos/Files.

Purpose: Enables TODOOO-specific mobile capabilities from CONTEXT.md - camera photos to canvas, TODO reminders, and flexible export options.

Output: Full native feature integration with proper permission handling on both platforms.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-mobile-platform/08-CONTEXT.md
@.planning/phases/08-mobile-platform/08-RESEARCH.md
@frontend/src/components/Canvas/CustomToolbar.tsx
@frontend/src/components/Canvas/fileHandling/useImageUpload.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create camera capture service</name>
  <files>frontend/src/capacitor/camera.ts</files>
  <action>
Create `frontend/src/capacitor/camera.ts`:

```typescript
/**
 * Camera capture service for adding photos to canvas.
 *
 * CONTEXT.md requirements:
 * - Camera: Yes - capture photos directly to canvas
 *
 * Uses Capacitor Camera plugin with native UI on iOS/Android.
 * Falls back to PWA camera on web (requires @ionic/pwa-elements).
 */
import { Camera, CameraResultType, CameraSource, Photo } from '@capacitor/camera';
import type { Editor } from 'tldraw';
import { isNativePlatform } from './platform';

/**
 * Capture a photo and add it to the tldraw canvas.
 *
 * Opens native camera on iOS/Android, PWA camera picker on web.
 * Creates an image shape at center of current viewport.
 *
 * @param editor - tldraw Editor instance
 * @param boardId - Current board ID (for asset upload)
 * @param token - Auth token for API calls
 * @param uploadImage - Function to upload image to storage
 */
export async function capturePhotoToCanvas(
  editor: Editor,
  boardId: string,
  token: string,
  uploadImage: (file: File, boardId: string, token: string) => Promise<string | null>
): Promise<boolean> {
  try {
    // Request camera permission and take photo
    const photo = await Camera.getPhoto({
      quality: 90,
      allowEditing: true,
      resultType: CameraResultType.Base64,
      source: CameraSource.Camera,
      width: 2048,  // Limit resolution for memory (RESEARCH.md Pitfall 2)
      height: 2048,
    });

    if (!photo.base64String) {
      console.warn('[Camera] No image data returned');
      return false;
    }

    // Convert base64 to File
    const file = base64ToFile(photo.base64String, photo.format || 'jpeg');

    // Upload via existing asset store
    const assetUrl = await uploadImage(file, boardId, token);
    if (!assetUrl) {
      console.error('[Camera] Failed to upload photo');
      return false;
    }

    // Create image shape at viewport center
    const { x, y } = editor.getViewportScreenCenter();
    const point = editor.screenToPage({ x, y });

    // Get image dimensions (approximate from typical photo aspect ratio)
    const img = new Image();
    img.src = `data:image/${photo.format || 'jpeg'};base64,${photo.base64String}`;

    await new Promise<void>((resolve) => {
      img.onload = () => resolve();
      img.onerror = () => resolve();
    });

    const width = Math.min(img.width || 400, 600);  // Max 600px display width
    const height = img.height ? (width / img.width) * img.height : width * 0.75;

    editor.createShape({
      type: 'image',
      x: point.x - width / 2,
      y: point.y - height / 2,
      props: {
        w: width,
        h: height,
        assetId: assetUrl,  // Reference to uploaded asset
      },
    });

    console.log('[Camera] Photo added to canvas');
    return true;
  } catch (error) {
    // User cancelled or permission denied
    if ((error as Error).message?.includes('User cancelled')) {
      console.log('[Camera] User cancelled photo capture');
      return false;
    }
    console.error('[Camera] Error capturing photo:', error);
    return false;
  }
}

/**
 * Check camera permission status.
 */
export async function checkCameraPermission(): Promise<'granted' | 'denied' | 'prompt'> {
  try {
    const result = await Camera.checkPermissions();
    return result.camera;
  } catch {
    return 'prompt';
  }
}

/**
 * Request camera permission.
 */
export async function requestCameraPermission(): Promise<boolean> {
  try {
    const result = await Camera.requestPermissions();
    return result.camera === 'granted';
  } catch {
    return false;
  }
}

// Helper to convert base64 to File
function base64ToFile(base64: string, format: string): File {
  const byteCharacters = atob(base64);
  const byteNumbers = new Array(byteCharacters.length);
  for (let i = 0; i < byteCharacters.length; i++) {
    byteNumbers[i] = byteCharacters.charCodeAt(i);
  }
  const byteArray = new Uint8Array(byteNumbers);
  const mimeType = `image/${format}`;
  const blob = new Blob([byteArray], { type: mimeType });
  return new File([blob], `photo_${Date.now()}.${format}`, { type: mimeType });
}
```
  </action>
  <verify>
- `cat frontend/src/capacitor/camera.ts` shows capturePhotoToCanvas function
- TypeScript compiles: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>Camera capture service created with permission handling</done>
</task>

<task type="auto">
  <name>Task 2: Create notifications and export services</name>
  <files>frontend/src/capacitor/notifications.ts, frontend/src/capacitor/exports.ts, frontend/src/capacitor/index.ts</files>
  <action>
1. Create `frontend/src/capacitor/notifications.ts`:

```typescript
/**
 * Local notification service for TODO reminders.
 *
 * CONTEXT.md requirements:
 * - Push notifications: Both collaborator activity AND TODO due date reminders
 *
 * Uses Capacitor LocalNotifications for scheduled reminders.
 * Note: Collaborator activity notifications require push infrastructure (future phase).
 */
import { LocalNotifications, ScheduleOptions } from '@capacitor/local-notifications';
import { isNativePlatform } from './platform';

// Map TODO IDs to notification IDs (numeric required by Capacitor)
const notificationIdMap = new Map<string, number>();
let nextNotificationId = 1;

/**
 * Get or create a numeric notification ID for a TODO.
 */
function getNotificationId(todoId: string): number {
  if (notificationIdMap.has(todoId)) {
    return notificationIdMap.get(todoId)!;
  }
  const id = nextNotificationId++;
  notificationIdMap.set(todoId, id);
  return id;
}

/**
 * Schedule a reminder notification for a TODO.
 *
 * @param todoId - Unique TODO identifier
 * @param title - TODO title to display in notification
 * @param dueDate - When to trigger the notification
 * @param reminderBefore - Minutes before due date to remind (default: 30)
 */
export async function scheduleTodoReminder(
  todoId: string,
  title: string,
  dueDate: Date,
  reminderBefore: number = 30
): Promise<boolean> {
  if (!isNativePlatform()) return false;

  try {
    // Request permission first
    const permission = await LocalNotifications.requestPermissions();
    if (permission.display !== 'granted') {
      console.warn('[Notifications] Permission not granted');
      return false;
    }

    // Calculate reminder time
    const reminderTime = new Date(dueDate.getTime() - reminderBefore * 60 * 1000);

    // Don't schedule if already past
    if (reminderTime <= new Date()) {
      console.log('[Notifications] Reminder time already passed');
      return false;
    }

    const notificationId = getNotificationId(todoId);

    // Cancel existing notification for this TODO
    await LocalNotifications.cancel({ notifications: [{ id: notificationId }] });

    // Schedule new notification
    await LocalNotifications.schedule({
      notifications: [{
        id: notificationId,
        title: 'TODO Reminder',
        body: title,
        schedule: { at: reminderTime },
        extra: { todoId },
        smallIcon: 'ic_stat_notification',
        iconColor: '#14b8a6',  // Teal brand color
      }],
    });

    console.log(`[Notifications] Scheduled reminder for "${title}" at ${reminderTime}`);
    return true;
  } catch (error) {
    console.error('[Notifications] Failed to schedule reminder:', error);
    return false;
  }
}

/**
 * Cancel a scheduled reminder for a TODO.
 */
export async function cancelTodoReminder(todoId: string): Promise<void> {
  if (!isNativePlatform()) return;

  const notificationId = notificationIdMap.get(todoId);
  if (notificationId) {
    await LocalNotifications.cancel({ notifications: [{ id: notificationId }] });
    notificationIdMap.delete(todoId);
    console.log(`[Notifications] Cancelled reminder for TODO ${todoId}`);
  }
}

/**
 * Check notification permission status.
 */
export async function checkNotificationPermission(): Promise<'granted' | 'denied' | 'prompt'> {
  if (!isNativePlatform()) return 'denied';

  try {
    const result = await LocalNotifications.checkPermissions();
    return result.display;
  } catch {
    return 'prompt';
  }
}
```

2. Create `frontend/src/capacitor/exports.ts`:

```typescript
/**
 * Export service for saving boards to Photos and Files.
 *
 * CONTEXT.md requirements:
 * - File exports: Both Photos app and Files app - user chooses destination per export
 */
import { Filesystem, Directory, Encoding } from '@capacitor/filesystem';
import { isNativePlatform, isIOS, isAndroid } from './platform';

/**
 * Export image data to device Photos/Gallery.
 *
 * @param base64Data - Base64 encoded image (without data URL prefix)
 * @param filename - Filename for the saved image
 * @returns Success status
 */
export async function exportToPhotos(
  base64Data: string,
  filename: string = `TODOOO_export_${Date.now()}.png`
): Promise<boolean> {
  if (!isNativePlatform()) {
    // Web fallback - trigger download
    downloadBase64(base64Data, filename, 'image/png');
    return true;
  }

  try {
    if (isIOS()) {
      // iOS: Write to photo library requires different approach
      // Use Filesystem to write, then share to Photos via native share
      await Filesystem.writeFile({
        path: filename,
        data: base64Data,
        directory: Directory.Cache,
      });

      // Note: Full Photos integration requires @capacitor/share or native module
      // For MVP, save to Files and user can manually add to Photos
      console.log('[Export] Saved to cache, use share to add to Photos');
      return true;
    }

    if (isAndroid()) {
      // Android: Write to Pictures directory
      await Filesystem.writeFile({
        path: `Pictures/TODOOO/${filename}`,
        data: base64Data,
        directory: Directory.ExternalStorage,
        recursive: true,
      });
      console.log('[Export] Saved to Pictures/TODOOO');
      return true;
    }

    return false;
  } catch (error) {
    console.error('[Export] Failed to export to Photos:', error);
    return false;
  }
}

/**
 * Export file to device Files/Documents.
 *
 * @param data - File data (base64 for binary, string for text)
 * @param filename - Filename including extension
 * @param mimeType - MIME type of the file
 * @returns Success status and saved path
 */
export async function exportToFiles(
  data: string,
  filename: string,
  mimeType: string = 'application/octet-stream'
): Promise<{ success: boolean; path?: string }> {
  if (!isNativePlatform()) {
    // Web fallback - trigger download
    downloadBase64(data, filename, mimeType);
    return { success: true };
  }

  try {
    const isText = mimeType.startsWith('text/') || mimeType === 'application/json';

    const result = await Filesystem.writeFile({
      path: `Documents/TODOOO/${filename}`,
      data: data,
      directory: Directory.ExternalStorage,
      encoding: isText ? Encoding.UTF8 : undefined,
      recursive: true,
    });

    console.log('[Export] Saved to Documents/TODOOO');
    return { success: true, path: result.uri };
  } catch (error) {
    console.error('[Export] Failed to export to Files:', error);

    // Fallback to cache directory
    try {
      const result = await Filesystem.writeFile({
        path: filename,
        data: data,
        directory: Directory.Cache,
      });
      console.log('[Export] Saved to cache as fallback');
      return { success: true, path: result.uri };
    } catch {
      return { success: false };
    }
  }
}

/**
 * Get the appropriate directory for exports.
 */
export function getExportDirectory(): string {
  if (isIOS()) return 'On My iPhone/TODOOO';
  if (isAndroid()) return 'Documents/TODOOO';
  return 'Downloads';
}

// Web fallback download helper
function downloadBase64(base64: string, filename: string, mimeType: string): void {
  const link = document.createElement('a');
  link.href = `data:${mimeType};base64,${base64}`;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
```

3. Update `frontend/src/capacitor/index.ts`:

```typescript
export * from './platform';
export * from './lifecycle';
export * from './offline';
export * from './camera';
export * from './notifications';
export * from './exports';
```
  </action>
  <verify>
- `cat frontend/src/capacitor/notifications.ts` shows scheduleTodoReminder
- `cat frontend/src/capacitor/exports.ts` shows exportToPhotos and exportToFiles
- `cat frontend/src/capacitor/index.ts` exports all modules
- TypeScript compiles: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>Notification and export services created</done>
</task>

<task type="auto">
  <name>Task 3: Configure native permissions and add camera button</name>
  <files>frontend/ios/App/App/Info.plist, frontend/android/app/src/main/AndroidManifest.xml, frontend/src/components/Canvas/CustomToolbar.tsx</files>
  <action>
1. Update iOS Info.plist (add after existing entries):

Find `frontend/ios/App/App/Info.plist` and add these keys inside the main `<dict>`:

```xml
<key>NSCameraUsageDescription</key>
<string>TODOOO needs camera access to add photos to your boards</string>
<key>NSPhotoLibraryUsageDescription</key>
<string>TODOOO needs photo library access to add images to your boards</string>
<key>NSPhotoLibraryAddUsageDescription</key>
<string>TODOOO needs permission to save exported images</string>
<key>ITSAppUsesNonExemptEncryption</key>
<false/>
```

2. Update Android AndroidManifest.xml:

Find `frontend/android/app/src/main/AndroidManifest.xml` and add permissions inside `<manifest>` before `<application>`:

```xml
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.CAMERA" />
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" android:maxSdkVersion="32" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="32" />
<uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
<uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
```

3. Update CustomToolbar.tsx to add camera button (mobile only):

Add import at top:
```typescript
import { isNativePlatform } from '../../capacitor/platform';
```

Add camera button in toolbar (after existing buttons, before the divider):
```tsx
{/* Camera button - mobile only */}
{isNativePlatform() && (
  <button
    onClick={() => {
      // Dispatch custom event for camera capture
      window.dispatchEvent(new CustomEvent('toolbar-camera-capture'));
    }}
    style={{
      width: 36,
      height: 36,
      border: 'none',
      borderRadius: 6,
      background: 'transparent',
      cursor: 'pointer',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      color: '#333',
    }}
    title="Take Photo"
  >
    {/* Camera icon SVG */}
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
      <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
      <circle cx="12" cy="13" r="4"/>
    </svg>
  </button>
)}
```

Note: The actual camera capture will be wired in Canvas.tsx (listening for 'toolbar-camera-capture' event).

If isNativePlatform is not available yet (plan 08-01 not complete), use a conditional try/catch:
```typescript
// Safe native platform check
function isMobileNative(): boolean {
  try {
    const { Capacitor } = require('@capacitor/core');
    return Capacitor.isNativePlatform();
  } catch {
    return false;
  }
}
```
  </action>
  <verify>
- `grep -n "NSCameraUsageDescription" frontend/ios/App/App/Info.plist` shows permission
- `grep -n "android.permission.CAMERA" frontend/android/app/src/main/AndroidManifest.xml` shows permission
- `grep -n "camera" frontend/src/components/Canvas/CustomToolbar.tsx` shows camera button
- `npm run build` completes without errors
  </verify>
  <done>Native permissions configured and camera button added to toolbar</done>
</task>

</tasks>

<verification>
1. `cat frontend/src/capacitor/camera.ts` shows photo capture function
2. `cat frontend/src/capacitor/notifications.ts` shows reminder scheduling
3. `cat frontend/src/capacitor/exports.ts` shows Photos/Files export
4. iOS Info.plist has camera and photo library permissions
5. Android manifest has camera, storage, and notification permissions
6. `npm run build` completes without errors
</verification>

<success_criteria>
- Camera capture service with base64 to File conversion
- Notification service with permission handling and scheduling
- Export service for Photos (gallery) and Files (documents)
- iOS Info.plist has NSCameraUsageDescription, NSPhotoLibraryUsageDescription
- Android manifest has CAMERA, storage, and notification permissions
- Camera button visible in toolbar on native platforms only
</success_criteria>

<output>
After completion, create `.planning/phases/08-mobile-platform/08-04-SUMMARY.md`
</output>
