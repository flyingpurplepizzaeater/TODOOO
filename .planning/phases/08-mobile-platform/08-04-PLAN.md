---
phase: 08-mobile-platform
plan: 04
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - frontend/src/capacitor/camera.ts
  - frontend/src/capacitor/notifications.ts
  - frontend/src/capacitor/exports.ts
  - frontend/src/capacitor/index.ts
  - frontend/src/components/Canvas/CustomToolbar.tsx
  - frontend/src/components/Canvas/Canvas.tsx
  - frontend/ios/App/App/Info.plist
  - frontend/android/app/src/main/AndroidManifest.xml
autonomous: true

must_haves:
  truths:
    - "User can capture photo and add it to canvas"
    - "User can schedule TODO reminder notifications"
    - "User receives local notification when collaborator joins/leaves board"
    - "User can export board to Photos app"
    - "User can export board to Files app"
    - "Camera permission prompt works on iOS and Android"
  artifacts:
    - path: "frontend/src/capacitor/camera.ts"
      provides: "Camera capture service"
      exports: ["capturePhotoToCanvas"]
    - path: "frontend/src/capacitor/notifications.ts"
      provides: "TODO reminder and collaborator activity notification service"
      exports: ["scheduleTodoReminder", "cancelTodoReminder", "notifyCollaboratorJoined", "notifyCollaboratorLeft"]
    - path: "frontend/src/capacitor/exports.ts"
      provides: "Export to Photos/Files service"
      exports: ["exportToPhotos", "exportToFiles"]
    - path: "frontend/ios/App/App/Info.plist"
      provides: "iOS permission descriptions"
      contains: "NSCameraUsageDescription"
    - path: "frontend/android/app/src/main/AndroidManifest.xml"
      provides: "Android permissions"
      contains: "android.permission.CAMERA"
  key_links:
    - from: "frontend/src/components/Canvas/CustomToolbar.tsx"
      to: "frontend/src/capacitor/camera.ts"
      via: "camera button click handler"
      pattern: "capturePhotoToCanvas"
    - from: "frontend/src/components/Canvas/Canvas.tsx"
      to: "toolbar-camera-capture event"
      via: "event listener wired to capturePhotoToCanvas"
      pattern: "addEventListener.*toolbar-camera-capture"
    - from: "frontend/src/components/Canvas/Canvas.tsx"
      to: "frontend/src/capacitor/notifications.ts"
      via: "awareness listener for collaborator notifications"
      pattern: "notifyCollaborator"
---

<objective>
Implement native mobile features: camera capture, push notifications, and export to Photos/Files.

Purpose: Enables TODOOO-specific mobile capabilities from CONTEXT.md - camera photos to canvas, TODO reminders, collaborator activity notifications, and flexible export options.

Output: Full native feature integration with proper permission handling on both platforms.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-mobile-platform/08-CONTEXT.md
@.planning/phases/08-mobile-platform/08-RESEARCH.md
@frontend/src/components/Canvas/CustomToolbar.tsx
@frontend/src/components/Canvas/Canvas.tsx
@frontend/src/components/Canvas/fileHandling/useImageUpload.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create camera capture service</name>
  <files>frontend/src/capacitor/camera.ts</files>
  <action>
Create `frontend/src/capacitor/camera.ts`:

```typescript
/**
 * Camera capture service for adding photos to canvas.
 *
 * CONTEXT.md requirements:
 * - Camera: Yes - capture photos directly to canvas
 *
 * Uses Capacitor Camera plugin with native UI on iOS/Android.
 * Falls back to PWA camera on web (requires @ionic/pwa-elements).
 */
import { Camera, CameraResultType, CameraSource, Photo } from '@capacitor/camera';
import type { Editor } from 'tldraw';
import { isNativePlatform } from './platform';

/**
 * Capture a photo and add it to the tldraw canvas.
 *
 * Opens native camera on iOS/Android, PWA camera picker on web.
 * Creates an image shape at center of current viewport.
 *
 * @param editor - tldraw Editor instance
 * @param boardId - Current board ID (for asset upload)
 * @param token - Auth token for API calls
 * @param uploadImage - Function to upload image to storage
 */
export async function capturePhotoToCanvas(
  editor: Editor,
  boardId: string,
  token: string,
  uploadImage: (file: File, boardId: string, token: string) => Promise<string | null>
): Promise<boolean> {
  try {
    // Request camera permission and take photo
    const photo = await Camera.getPhoto({
      quality: 90,
      allowEditing: true,
      resultType: CameraResultType.Base64,
      source: CameraSource.Camera,
      width: 2048,  // Limit resolution for memory (RESEARCH.md Pitfall 2)
      height: 2048,
    });

    if (!photo.base64String) {
      console.warn('[Camera] No image data returned');
      return false;
    }

    // Convert base64 to File
    const file = base64ToFile(photo.base64String, photo.format || 'jpeg');

    // Upload via existing asset store
    const assetUrl = await uploadImage(file, boardId, token);
    if (!assetUrl) {
      console.error('[Camera] Failed to upload photo');
      return false;
    }

    // Create image shape at viewport center
    const { x, y } = editor.getViewportScreenCenter();
    const point = editor.screenToPage({ x, y });

    // Get image dimensions (approximate from typical photo aspect ratio)
    const img = new Image();
    img.src = `data:image/${photo.format || 'jpeg'};base64,${photo.base64String}`;

    await new Promise<void>((resolve) => {
      img.onload = () => resolve();
      img.onerror = () => resolve();
    });

    const width = Math.min(img.width || 400, 600);  // Max 600px display width
    const height = img.height ? (width / img.width) * img.height : width * 0.75;

    editor.createShape({
      type: 'image',
      x: point.x - width / 2,
      y: point.y - height / 2,
      props: {
        w: width,
        h: height,
        assetId: assetUrl,  // Reference to uploaded asset
      },
    });

    console.log('[Camera] Photo added to canvas');
    return true;
  } catch (error) {
    // User cancelled or permission denied
    if ((error as Error).message?.includes('User cancelled')) {
      console.log('[Camera] User cancelled photo capture');
      return false;
    }
    console.error('[Camera] Error capturing photo:', error);
    return false;
  }
}

/**
 * Check camera permission status.
 */
export async function checkCameraPermission(): Promise<'granted' | 'denied' | 'prompt'> {
  try {
    const result = await Camera.checkPermissions();
    return result.camera;
  } catch {
    return 'prompt';
  }
}

/**
 * Request camera permission.
 */
export async function requestCameraPermission(): Promise<boolean> {
  try {
    const result = await Camera.requestPermissions();
    return result.camera === 'granted';
  } catch {
    return false;
  }
}

// Helper to convert base64 to File
function base64ToFile(base64: string, format: string): File {
  const byteCharacters = atob(base64);
  const byteNumbers = new Array(byteCharacters.length);
  for (let i = 0; i < byteCharacters.length; i++) {
    byteNumbers[i] = byteCharacters.charCodeAt(i);
  }
  const byteArray = new Uint8Array(byteNumbers);
  const mimeType = `image/${format}`;
  const blob = new Blob([byteArray], { type: mimeType });
  return new File([blob], `photo_${Date.now()}.${format}`, { type: mimeType });
}
```
  </action>
  <verify>
- `cat frontend/src/capacitor/camera.ts` shows capturePhotoToCanvas function
- TypeScript compiles: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>Camera capture service created with permission handling</done>
</task>

<task type="auto">
  <name>Task 2: Create notifications and export services</name>
  <files>frontend/src/capacitor/notifications.ts, frontend/src/capacitor/exports.ts, frontend/src/capacitor/index.ts</files>
  <action>
1. Create `frontend/src/capacitor/notifications.ts`:

```typescript
/**
 * Local notification service for TODO reminders AND collaborator activity.
 *
 * CONTEXT.md requirements:
 * - Push notifications: Both collaborator activity AND TODO due date reminders
 *
 * Implementation note: Uses Capacitor LocalNotifications for BOTH use cases.
 * - TODO reminders: Scheduled notifications at due date
 * - Collaborator activity: Immediate local notifications triggered by WebSocket awareness events
 *
 * This approach avoids needing push infrastructure (FCM, APNs) for MVP.
 * The WebSocket connection already delivers real-time awareness updates;
 * we simply show a local notification when those events fire.
 */
import { LocalNotifications, ScheduleOptions } from '@capacitor/local-notifications';
import { isNativePlatform } from './platform';

// Map TODO IDs to notification IDs (numeric required by Capacitor)
const notificationIdMap = new Map<string, number>();
let nextNotificationId = 1;

// Collaborator notification IDs start at 100000 to avoid collision
let nextCollaboratorNotificationId = 100000;

/**
 * Get or create a numeric notification ID for a TODO.
 */
function getNotificationId(todoId: string): number {
  if (notificationIdMap.has(todoId)) {
    return notificationIdMap.get(todoId)!;
  }
  const id = nextNotificationId++;
  notificationIdMap.set(todoId, id);
  return id;
}

/**
 * Schedule a reminder notification for a TODO.
 *
 * @param todoId - Unique TODO identifier
 * @param title - TODO title to display in notification
 * @param dueDate - When to trigger the notification
 * @param reminderBefore - Minutes before due date to remind (default: 30)
 */
export async function scheduleTodoReminder(
  todoId: string,
  title: string,
  dueDate: Date,
  reminderBefore: number = 30
): Promise<boolean> {
  if (!isNativePlatform()) return false;

  try {
    // Request permission first
    const permission = await LocalNotifications.requestPermissions();
    if (permission.display !== 'granted') {
      console.warn('[Notifications] Permission not granted');
      return false;
    }

    // Calculate reminder time
    const reminderTime = new Date(dueDate.getTime() - reminderBefore * 60 * 1000);

    // Don't schedule if already past
    if (reminderTime <= new Date()) {
      console.log('[Notifications] Reminder time already passed');
      return false;
    }

    const notificationId = getNotificationId(todoId);

    // Cancel existing notification for this TODO
    await LocalNotifications.cancel({ notifications: [{ id: notificationId }] });

    // Schedule new notification
    await LocalNotifications.schedule({
      notifications: [{
        id: notificationId,
        title: 'TODO Reminder',
        body: title,
        schedule: { at: reminderTime },
        extra: { todoId },
        smallIcon: 'ic_stat_notification',
        iconColor: '#14b8a6',  // Teal brand color
      }],
    });

    console.log(`[Notifications] Scheduled reminder for "${title}" at ${reminderTime}`);
    return true;
  } catch (error) {
    console.error('[Notifications] Failed to schedule reminder:', error);
    return false;
  }
}

/**
 * Cancel a scheduled reminder for a TODO.
 */
export async function cancelTodoReminder(todoId: string): Promise<void> {
  if (!isNativePlatform()) return;

  const notificationId = notificationIdMap.get(todoId);
  if (notificationId) {
    await LocalNotifications.cancel({ notifications: [{ id: notificationId }] });
    notificationIdMap.delete(todoId);
    console.log(`[Notifications] Cancelled reminder for TODO ${todoId}`);
  }
}

/**
 * Show immediate local notification when collaborator joins the board.
 *
 * Called from Canvas.tsx when awareness 'update' event detects a new user.
 *
 * @param userName - Name of the collaborator who joined
 * @param boardName - Name of the board (optional)
 */
export async function notifyCollaboratorJoined(
  userName: string,
  boardName?: string
): Promise<void> {
  if (!isNativePlatform()) return;

  try {
    const permission = await LocalNotifications.checkPermissions();
    if (permission.display !== 'granted') return;

    const id = nextCollaboratorNotificationId++;
    const body = boardName
      ? `${userName} joined "${boardName}"`
      : `${userName} joined the board`;

    await LocalNotifications.schedule({
      notifications: [{
        id,
        title: 'Collaborator Joined',
        body,
        smallIcon: 'ic_stat_notification',
        iconColor: '#14b8a6',
      }],
    });

    console.log(`[Notifications] Collaborator joined: ${userName}`);
  } catch (error) {
    console.error('[Notifications] Failed to notify collaborator join:', error);
  }
}

/**
 * Show immediate local notification when collaborator leaves the board.
 *
 * Called from Canvas.tsx when awareness 'update' event detects user departure.
 *
 * @param userName - Name of the collaborator who left
 * @param boardName - Name of the board (optional)
 */
export async function notifyCollaboratorLeft(
  userName: string,
  boardName?: string
): Promise<void> {
  if (!isNativePlatform()) return;

  try {
    const permission = await LocalNotifications.checkPermissions();
    if (permission.display !== 'granted') return;

    const id = nextCollaboratorNotificationId++;
    const body = boardName
      ? `${userName} left "${boardName}"`
      : `${userName} left the board`;

    await LocalNotifications.schedule({
      notifications: [{
        id,
        title: 'Collaborator Left',
        body,
        smallIcon: 'ic_stat_notification',
        iconColor: '#14b8a6',
      }],
    });

    console.log(`[Notifications] Collaborator left: ${userName}`);
  } catch (error) {
    console.error('[Notifications] Failed to notify collaborator leave:', error);
  }
}

/**
 * Check notification permission status.
 */
export async function checkNotificationPermission(): Promise<'granted' | 'denied' | 'prompt'> {
  if (!isNativePlatform()) return 'denied';

  try {
    const result = await LocalNotifications.checkPermissions();
    return result.display;
  } catch {
    return 'prompt';
  }
}

/**
 * Request notification permission.
 * Call this early in app lifecycle (e.g., on first board view).
 */
export async function requestNotificationPermission(): Promise<boolean> {
  if (!isNativePlatform()) return false;

  try {
    const result = await LocalNotifications.requestPermissions();
    return result.display === 'granted';
  } catch {
    return false;
  }
}
```

2. Create `frontend/src/capacitor/exports.ts`:

```typescript
/**
 * Export service for saving boards to Photos and Files.
 *
 * CONTEXT.md requirements:
 * - File exports: Both Photos app and Files app - user chooses destination per export
 */
import { Filesystem, Directory, Encoding } from '@capacitor/filesystem';
import { isNativePlatform, isIOS, isAndroid } from './platform';

/**
 * Export image data to device Photos/Gallery.
 *
 * @param base64Data - Base64 encoded image (without data URL prefix)
 * @param filename - Filename for the saved image
 * @returns Success status
 */
export async function exportToPhotos(
  base64Data: string,
  filename: string = `TODOOO_export_${Date.now()}.png`
): Promise<boolean> {
  if (!isNativePlatform()) {
    // Web fallback - trigger download
    downloadBase64(base64Data, filename, 'image/png');
    return true;
  }

  try {
    if (isIOS()) {
      // iOS: Write to photo library requires different approach
      // Use Filesystem to write, then share to Photos via native share
      await Filesystem.writeFile({
        path: filename,
        data: base64Data,
        directory: Directory.Cache,
      });

      // Note: Full Photos integration requires @capacitor/share or native module
      // For MVP, save to Files and user can manually add to Photos
      console.log('[Export] Saved to cache, use share to add to Photos');
      return true;
    }

    if (isAndroid()) {
      // Android: Write to Pictures directory
      await Filesystem.writeFile({
        path: `Pictures/TODOOO/${filename}`,
        data: base64Data,
        directory: Directory.ExternalStorage,
        recursive: true,
      });
      console.log('[Export] Saved to Pictures/TODOOO');
      return true;
    }

    return false;
  } catch (error) {
    console.error('[Export] Failed to export to Photos:', error);
    return false;
  }
}

/**
 * Export file to device Files/Documents.
 *
 * @param data - File data (base64 for binary, string for text)
 * @param filename - Filename including extension
 * @param mimeType - MIME type of the file
 * @returns Success status and saved path
 */
export async function exportToFiles(
  data: string,
  filename: string,
  mimeType: string = 'application/octet-stream'
): Promise<{ success: boolean; path?: string }> {
  if (!isNativePlatform()) {
    // Web fallback - trigger download
    downloadBase64(data, filename, mimeType);
    return { success: true };
  }

  try {
    const isText = mimeType.startsWith('text/') || mimeType === 'application/json';

    const result = await Filesystem.writeFile({
      path: `Documents/TODOOO/${filename}`,
      data: data,
      directory: Directory.ExternalStorage,
      encoding: isText ? Encoding.UTF8 : undefined,
      recursive: true,
    });

    console.log('[Export] Saved to Documents/TODOOO');
    return { success: true, path: result.uri };
  } catch (error) {
    console.error('[Export] Failed to export to Files:', error);

    // Fallback to cache directory
    try {
      const result = await Filesystem.writeFile({
        path: filename,
        data: data,
        directory: Directory.Cache,
      });
      console.log('[Export] Saved to cache as fallback');
      return { success: true, path: result.uri };
    } catch {
      return { success: false };
    }
  }
}

/**
 * Get the appropriate directory for exports.
 */
export function getExportDirectory(): string {
  if (isIOS()) return 'On My iPhone/TODOOO';
  if (isAndroid()) return 'Documents/TODOOO';
  return 'Downloads';
}

// Web fallback download helper
function downloadBase64(base64: string, filename: string, mimeType: string): void {
  const link = document.createElement('a');
  link.href = `data:${mimeType};base64,${base64}`;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}
```

3. Update `frontend/src/capacitor/index.ts`:

```typescript
export * from './platform';
export * from './lifecycle';
export * from './offline';
export * from './camera';
export * from './notifications';
export * from './exports';
```
  </action>
  <verify>
- `cat frontend/src/capacitor/notifications.ts` shows scheduleTodoReminder AND notifyCollaboratorJoined/Left
- `cat frontend/src/capacitor/exports.ts` shows exportToPhotos and exportToFiles
- `cat frontend/src/capacitor/index.ts` exports all modules
- TypeScript compiles: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>Notification service (with collaborator activity) and export services created</done>
</task>

<task type="auto">
  <name>Task 3: Configure native permissions, add camera button, and wire event listeners</name>
  <files>frontend/ios/App/App/Info.plist, frontend/android/app/src/main/AndroidManifest.xml, frontend/src/components/Canvas/CustomToolbar.tsx, frontend/src/components/Canvas/Canvas.tsx</files>
  <action>
1. Update iOS Info.plist (add after existing entries):

Find `frontend/ios/App/App/Info.plist` and add these keys inside the main `<dict>`:

```xml
<key>NSCameraUsageDescription</key>
<string>TODOOO needs camera access to add photos to your boards</string>
<key>NSPhotoLibraryUsageDescription</key>
<string>TODOOO needs photo library access to add images to your boards</string>
<key>NSPhotoLibraryAddUsageDescription</key>
<string>TODOOO needs permission to save exported images</string>
<key>ITSAppUsesNonExemptEncryption</key>
<false/>
```

2. Update Android AndroidManifest.xml:

Find `frontend/android/app/src/main/AndroidManifest.xml` and add permissions inside `<manifest>` before `<application>`:

```xml
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.CAMERA" />
<uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" android:maxSdkVersion="32" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="32" />
<uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
<uses-permission android:name="android.permission.SCHEDULE_EXACT_ALARM" />
```

3. Update CustomToolbar.tsx to add camera button (mobile only):

Add import at top:
```typescript
import { isNativePlatform } from '../../capacitor/platform';
```

Add camera button in toolbar (after existing buttons, before the divider):
```tsx
{/* Camera button - mobile only */}
{isNativePlatform() && (
  <button
    onClick={() => {
      // Dispatch custom event for camera capture
      window.dispatchEvent(new CustomEvent('toolbar-camera-capture'));
    }}
    style={{
      width: 36,
      height: 36,
      border: 'none',
      borderRadius: 6,
      background: 'transparent',
      cursor: 'pointer',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      color: '#333',
    }}
    title="Take Photo"
  >
    {/* Camera icon SVG */}
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
      <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/>
      <circle cx="12" cy="13" r="4"/>
    </svg>
  </button>
)}
```

If isNativePlatform is not available yet (plan 08-01 not complete), use a conditional try/catch:
```typescript
// Safe native platform check
function isMobileNative(): boolean {
  try {
    const { Capacitor } = require('@capacitor/core');
    return Capacitor.isNativePlatform();
  } catch {
    return false;
  }
}
```

4. **CRITICAL: Wire camera button event listener in Canvas.tsx**

Add imports to Canvas.tsx:
```typescript
import { capturePhotoToCanvas } from '../../capacitor/camera';
import { notifyCollaboratorJoined, notifyCollaboratorLeft } from '../../capacitor/notifications';
import { isNativePlatform } from '../../capacitor/platform';
```

Add useEffect for camera button event listener:
```typescript
// Listen for camera capture event from toolbar button
useEffect(() => {
  if (!isNativePlatform()) return;

  const handleCameraCapture = async () => {
    if (!editorRef.current || !boardId || !token) return;

    // Use existing uploadImage function from useImageUpload hook
    // (adapt based on actual implementation in useImageUpload.ts)
    const success = await capturePhotoToCanvas(
      editorRef.current,
      boardId,
      token,
      async (file, boardId, token) => {
        // Integration point with existing image upload
        // This should use the same upload flow as drag-drop images
        // Return the asset URL after upload
        try {
          const formData = new FormData();
          formData.append('file', file);
          const response = await fetch(`/api/boards/${boardId}/assets`, {
            method: 'POST',
            headers: { Authorization: `Bearer ${token}` },
            body: formData,
          });
          if (!response.ok) return null;
          const { url } = await response.json();
          return url;
        } catch {
          return null;
        }
      }
    );

    if (success) {
      console.log('[Canvas] Camera photo added successfully');
    }
  };

  window.addEventListener('toolbar-camera-capture', handleCameraCapture);
  return () => {
    window.removeEventListener('toolbar-camera-capture', handleCameraCapture);
  };
}, [boardId, token]);
```

5. **Wire collaborator activity notifications to awareness events**

In Canvas.tsx, within the useEffect that sets up the awareness listener (or create new one):
```typescript
// Collaborator activity notifications (mobile only)
useEffect(() => {
  if (!isNativePlatform() || !provider?.awareness) return;

  // Track known users to detect joins/leaves
  const knownUsers = new Set<number>();

  const handleAwarenessUpdate = () => {
    const states = provider.awareness.getStates();
    const currentUsers = new Set<number>();

    // Check each connected user
    states.forEach((state, clientId) => {
      if (clientId === provider.awareness.clientID) return; // Skip self

      currentUsers.add(clientId);
      const user = state.user as { name?: string } | undefined;
      const userName = user?.name || 'Someone';

      // New user joined
      if (!knownUsers.has(clientId)) {
        notifyCollaboratorJoined(userName);
      }
    });

    // Check for users who left
    knownUsers.forEach(clientId => {
      if (!currentUsers.has(clientId)) {
        // User left - we may not have their name anymore
        // Could track names separately or use generic message
        notifyCollaboratorLeft('A collaborator');
      }
    });

    // Update known users
    knownUsers.clear();
    currentUsers.forEach(id => knownUsers.add(id));
  };

  provider.awareness.on('update', handleAwarenessUpdate);

  return () => {
    provider.awareness.off('update', handleAwarenessUpdate);
  };
}, [provider]);
```
  </action>
  <verify>
- `grep -n "NSCameraUsageDescription" frontend/ios/App/App/Info.plist` shows permission
- `grep -n "android.permission.CAMERA" frontend/android/app/src/main/AndroidManifest.xml` shows permission
- `grep -n "camera" frontend/src/components/Canvas/CustomToolbar.tsx` shows camera button
- `grep -n "toolbar-camera-capture" frontend/src/components/Canvas/Canvas.tsx` shows event listener wired
- `grep -n "notifyCollaboratorJoined" frontend/src/components/Canvas/Canvas.tsx` shows awareness wiring
- `npm run build` completes without errors
  </verify>
  <done>Native permissions configured, camera button added, and event listeners wired in Canvas.tsx</done>
</task>

</tasks>

<verification>
1. `cat frontend/src/capacitor/camera.ts` shows photo capture function
2. `cat frontend/src/capacitor/notifications.ts` shows reminder scheduling AND collaborator notification functions
3. `cat frontend/src/capacitor/exports.ts` shows Photos/Files export
4. iOS Info.plist has camera and photo library permissions
5. Android manifest has camera, storage, and notification permissions
6. Camera button dispatches event AND Canvas.tsx listens for it
7. Awareness updates trigger collaborator notifications
8. `npm run build` completes without errors
</verification>

<success_criteria>
- Camera capture service with base64 to File conversion
- Notification service with permission handling, TODO scheduling, AND collaborator activity
- Export service for Photos (gallery) and Files (documents)
- iOS Info.plist has NSCameraUsageDescription, NSPhotoLibraryUsageDescription
- Android manifest has CAMERA, storage, and notification permissions
- Camera button visible in toolbar on native platforms only
- Camera button event wired to capturePhotoToCanvas in Canvas.tsx
- Awareness updates trigger local notifications for collaborator join/leave
</success_criteria>

<output>
After completion, create `.planning/phases/08-mobile-platform/08-04-SUMMARY.md`
</output>
