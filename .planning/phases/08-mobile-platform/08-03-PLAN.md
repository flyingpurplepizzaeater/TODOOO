---
phase: 08-mobile-platform
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - frontend/src/capacitor/lifecycle.ts
  - frontend/src/capacitor/offline.ts
  - frontend/src/components/Canvas/ConnectionBanner.tsx
  - frontend/src/components/Canvas/Canvas.tsx
  - frontend/src/main.tsx
  - frontend/src/capacitor/index.ts
autonomous: true

must_haves:
  truths:
    - "App reconnects WebSocket when returning from background"
    - "Connection lost shows warning banner"
    - "Reconnection shows success banner that auto-dismisses"
    - "Last 10 boards are cached for offline access"
    - "Cached boards load when offline"
  artifacts:
    - path: "frontend/src/capacitor/lifecycle.ts"
      provides: "App lifecycle handlers for WebSocket reconnection"
      exports: ["initAppLifecycle", "cleanupAppLifecycle"]
    - path: "frontend/src/capacitor/offline.ts"
      provides: "Board caching service"
      exports: ["cacheBoard", "getCachedBoard", "getCachedBoardList"]
    - path: "frontend/src/components/Canvas/ConnectionBanner.tsx"
      provides: "Connection status UI component"
      exports: ["ConnectionBanner"]
  key_links:
    - from: "frontend/src/capacitor/lifecycle.ts"
      to: "y-websocket provider"
      via: "provider.connect() call"
      pattern: "provider\\.connect"
    - from: "frontend/src/components/Canvas/Canvas.tsx"
      to: "frontend/src/components/Canvas/ConnectionBanner.tsx"
      via: "ConnectionBanner import"
      pattern: "import.*ConnectionBanner"
---

<objective>
Implement app lifecycle handling and offline caching for mobile resilience.

Purpose: Mobile apps frequently go to background (switching apps, receiving calls). Without lifecycle handling, WebSocket disconnects and users lose sync. Offline caching enables cold start without network.

Output: Resilient mobile app that reconnects automatically and works offline with cached boards.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-mobile-platform/08-CONTEXT.md
@.planning/phases/08-mobile-platform/08-RESEARCH.md
@frontend/src/components/Canvas/Canvas.tsx
@frontend/src/components/Canvas/useYjsStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create app lifecycle handler for WebSocket reconnection</name>
  <files>frontend/src/capacitor/lifecycle.ts</files>
  <action>
Create `frontend/src/capacitor/lifecycle.ts`:

```typescript
/**
 * App lifecycle handlers for Capacitor mobile apps.
 *
 * Handles WebSocket reconnection when app returns from background.
 * Mobile OS suspends WebView when backgrounded, killing WebSocket connections.
 *
 * RESEARCH.md Pitfall 1: WebSocket Disconnection on Background
 * Solution: Listen for appStateChange and resume events, reconnect provider.
 */
import { App, type AppState } from '@capacitor/app';
import { isNativePlatform } from './platform';
import type { WebsocketProvider } from 'y-websocket';

// Store cleanup functions for removal
let appStateListener: (() => void) | null = null;
let resumeListener: (() => void) | null = null;
let backButtonListener: (() => void) | null = null;

// Current provider reference
let currentProvider: WebsocketProvider | null = null;

/**
 * Initialize app lifecycle handlers for WebSocket reconnection.
 *
 * Call this after WebSocket provider is created, typically in useYjsStore.
 *
 * @param provider - y-websocket provider instance
 */
export async function initAppLifecycle(provider: WebsocketProvider): Promise<void> {
  // Only set up native listeners on Capacitor platforms
  if (!isNativePlatform()) return;

  currentProvider = provider;

  // Handle app state changes (foreground/background)
  const stateHandle = await App.addListener('appStateChange', (state: AppState) => {
    if (state.isActive && currentProvider) {
      // App returned to foreground - reconnect if disconnected
      if (!currentProvider.wsconnected) {
        console.log('[Lifecycle] App resumed, reconnecting WebSocket...');
        currentProvider.connect();
      }
    }
  });
  appStateListener = () => stateHandle.remove();

  // Handle explicit resume event (more reliable on some devices)
  const resumeHandle = await App.addListener('resume', () => {
    if (currentProvider && !currentProvider.wsconnected) {
      console.log('[Lifecycle] Resume event, reconnecting WebSocket...');
      currentProvider.connect();
    }
  });
  resumeListener = () => resumeHandle.remove();

  // Handle Android back button
  // RESEARCH.md Pitfall 3: Android Back Button Closes App
  const backHandle = await App.addListener('backButton', ({ canGoBack }) => {
    if (canGoBack) {
      window.history.back();
    } else {
      // At root - could show "press again to exit" toast
      // For now, let default behavior exit the app
    }
  });
  backButtonListener = () => backHandle.remove();
}

/**
 * Update the provider reference when it changes.
 * Call when reconnecting with a new provider instance.
 */
export function updateProvider(provider: WebsocketProvider): void {
  currentProvider = provider;
}

/**
 * Clean up lifecycle listeners.
 * Call on component unmount or when changing boards.
 */
export function cleanupAppLifecycle(): void {
  appStateListener?.();
  resumeListener?.();
  backButtonListener?.();
  appStateListener = null;
  resumeListener = null;
  backButtonListener = null;
  currentProvider = null;
}
```
  </action>
  <verify>
- `cat frontend/src/capacitor/lifecycle.ts` shows App listeners
- TypeScript compiles: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>App lifecycle handler created with WebSocket reconnection on resume</done>
</task>

<task type="auto">
  <name>Task 2: Create offline board caching service</name>
  <files>frontend/src/capacitor/offline.ts</files>
  <action>
Create `frontend/src/capacitor/offline.ts`:

```typescript
/**
 * Offline board caching service.
 *
 * CONTEXT.md requirements:
 * - Cold start offline: Show cached boards (last-viewed boards available)
 * - Cache size: Last 10 boards
 *
 * Uses Capacitor Filesystem for data storage and Preferences for metadata.
 */
import { Filesystem, Directory, Encoding } from '@capacitor/filesystem';
import { Preferences } from '@capacitor/preferences';
import { isNativePlatform } from './platform';

const MAX_CACHED_BOARDS = 10;
const CACHE_KEY = 'cached-boards';
const BOARDS_DIR = 'boards';

/**
 * Metadata for a cached board.
 */
export interface CachedBoardMeta {
  boardId: string;
  name: string;
  lastViewed: number;
}

/**
 * Full cached board data.
 */
interface CachedBoardData {
  boardId: string;
  name: string;
  lastViewed: number;
  yjsState: string;  // Base64 encoded Y.Doc state
}

/**
 * Cache a board's Y.Doc state for offline access.
 *
 * @param boardId - Board UUID
 * @param name - Board display name
 * @param yjsState - Y.Doc state as Uint8Array
 */
export async function cacheBoard(
  boardId: string,
  name: string,
  yjsState: Uint8Array
): Promise<void> {
  if (!isNativePlatform()) return;

  try {
    // Get current cache list
    const { value } = await Preferences.get({ key: CACHE_KEY });
    const boards: CachedBoardMeta[] = value ? JSON.parse(value) : [];

    // Remove if exists (to update position)
    const filtered = boards.filter(b => b.boardId !== boardId);

    // Add to front (most recent)
    filtered.unshift({
      boardId,
      name,
      lastViewed: Date.now(),
    });

    // Keep only MAX_CACHED_BOARDS
    const trimmed = filtered.slice(0, MAX_CACHED_BOARDS);

    // Remove old boards from filesystem if over limit
    const removedIds = boards
      .slice(MAX_CACHED_BOARDS)
      .map(b => b.boardId);
    for (const id of removedIds) {
      try {
        await Filesystem.deleteFile({
          path: `${BOARDS_DIR}/${id}.json`,
          directory: Directory.Data,
        });
      } catch {
        // Ignore deletion errors
      }
    }

    // Save metadata list
    await Preferences.set({
      key: CACHE_KEY,
      value: JSON.stringify(trimmed),
    });

    // Convert Uint8Array to base64
    const base64 = uint8ArrayToBase64(yjsState);

    // Ensure directory exists
    try {
      await Filesystem.mkdir({
        path: BOARDS_DIR,
        directory: Directory.Data,
        recursive: true,
      });
    } catch {
      // Directory might already exist
    }

    // Save board state to filesystem
    await Filesystem.writeFile({
      path: `${BOARDS_DIR}/${boardId}.json`,
      data: JSON.stringify({ yjsState: base64 }),
      directory: Directory.Data,
      encoding: Encoding.UTF8,
    });

    console.log(`[Offline] Cached board ${boardId}`);
  } catch (error) {
    console.error('[Offline] Failed to cache board:', error);
  }
}

/**
 * Get cached board state for offline loading.
 *
 * @param boardId - Board UUID
 * @returns Y.Doc state as Uint8Array, or null if not cached
 */
export async function getCachedBoard(boardId: string): Promise<Uint8Array | null> {
  if (!isNativePlatform()) return null;

  try {
    const result = await Filesystem.readFile({
      path: `${BOARDS_DIR}/${boardId}.json`,
      directory: Directory.Data,
      encoding: Encoding.UTF8,
    });

    const data = JSON.parse(result.data as string) as { yjsState: string };
    return base64ToUint8Array(data.yjsState);
  } catch {
    return null;
  }
}

/**
 * Get list of cached boards (metadata only).
 *
 * @returns Array of cached board metadata, most recent first
 */
export async function getCachedBoardList(): Promise<CachedBoardMeta[]> {
  if (!isNativePlatform()) return [];

  try {
    const { value } = await Preferences.get({ key: CACHE_KEY });
    return value ? JSON.parse(value) : [];
  } catch {
    return [];
  }
}

/**
 * Check if a board is cached.
 */
export async function isBoardCached(boardId: string): Promise<boolean> {
  const list = await getCachedBoardList();
  return list.some(b => b.boardId === boardId);
}

/**
 * Clear all cached boards.
 */
export async function clearCache(): Promise<void> {
  if (!isNativePlatform()) return;

  try {
    const boards = await getCachedBoardList();
    for (const board of boards) {
      try {
        await Filesystem.deleteFile({
          path: `${BOARDS_DIR}/${board.boardId}.json`,
          directory: Directory.Data,
        });
      } catch {
        // Ignore
      }
    }
    await Preferences.remove({ key: CACHE_KEY });
  } catch (error) {
    console.error('[Offline] Failed to clear cache:', error);
  }
}

// Utility functions for base64 conversion
function uint8ArrayToBase64(bytes: Uint8Array): string {
  let binary = '';
  for (let i = 0; i < bytes.length; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

function base64ToUint8Array(base64: string): Uint8Array {
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
}
```

Update `frontend/src/capacitor/index.ts` to export new modules:
```typescript
export * from './platform';
export * from './lifecycle';
export * from './offline';
```
  </action>
  <verify>
- `cat frontend/src/capacitor/offline.ts` shows cacheBoard and getCachedBoard functions
- `cat frontend/src/capacitor/index.ts` exports offline module
- TypeScript compiles: `cd frontend && npx tsc --noEmit`
  </verify>
  <done>Offline board caching service created with 10-board limit</done>
</task>

<task type="auto">
  <name>Task 3: Create ConnectionBanner component and integrate</name>
  <files>frontend/src/components/Canvas/ConnectionBanner.tsx, frontend/src/components/Canvas/Canvas.tsx, frontend/src/main.tsx</files>
  <action>
1. Create `frontend/src/components/Canvas/ConnectionBanner.tsx`:

```typescript
/**
 * Connection status banner for mobile apps.
 *
 * CONTEXT.md requirements:
 * - Connection loss: Warning banner but allow continued editing
 * - Reconnection: Auto-dismiss banner ("Reconnected!" fades after 2-3s)
 */
import { useEffect, useState, useRef } from 'react';
import type { ConnectionStatus } from './useYjsStore';

interface ConnectionBannerProps {
  status: ConnectionStatus;
}

/**
 * Shows connection status banners for disconnection and reconnection.
 *
 * - Disconnected: Persistent warning banner
 * - Reconnected: Success banner that auto-dismisses after 2.5s
 */
export function ConnectionBanner({ status }: ConnectionBannerProps) {
  const [showReconnected, setShowReconnected] = useState(false);
  const wasDisconnectedRef = useRef(false);

  useEffect(() => {
    if (status === 'disconnected' || status === 'error') {
      wasDisconnectedRef.current = true;
    }

    if (status === 'connected' && wasDisconnectedRef.current) {
      setShowReconnected(true);
      wasDisconnectedRef.current = false;

      // Auto-dismiss after 2.5 seconds per CONTEXT.md
      const timer = setTimeout(() => setShowReconnected(false), 2500);
      return () => clearTimeout(timer);
    }
  }, [status]);

  // Disconnected/error banner
  if (status === 'disconnected' || status === 'error') {
    return (
      <div style={{
        position: 'absolute',
        top: 48,
        left: '50%',
        transform: 'translateX(-50%)',
        zIndex: 1001,
        padding: '8px 16px',
        borderRadius: 8,
        background: '#fef3c7',
        border: '1px solid #f59e0b',
        color: '#92400e',
        fontSize: 14,
        fontFamily: 'system-ui, sans-serif',
        fontWeight: 500,
        boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
        display: 'flex',
        alignItems: 'center',
        gap: 8,
      }}>
        <span style={{ fontSize: 16 }}>!</span>
        Connection lost. Changes saved locally.
      </div>
    );
  }

  // Reconnected success banner
  if (showReconnected) {
    return (
      <div style={{
        position: 'absolute',
        top: 48,
        left: '50%',
        transform: 'translateX(-50%)',
        zIndex: 1001,
        padding: '8px 16px',
        borderRadius: 8,
        background: '#d1fae5',
        border: '1px solid #10b981',
        color: '#065f46',
        fontSize: 14,
        fontFamily: 'system-ui, sans-serif',
        fontWeight: 500,
        boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
        animation: 'fadeIn 0.3s ease-out',
      }}>
        Reconnected!
      </div>
    );
  }

  return null;
}
```

2. Update `frontend/src/components/Canvas/Canvas.tsx` to:
- Import ConnectionBanner
- Import lifecycle handlers
- Initialize lifecycle on provider creation
- Add ConnectionBanner to render

Add imports:
```typescript
import { ConnectionBanner } from './ConnectionBanner'
import { initAppLifecycle, cleanupAppLifecycle } from '../../capacitor/lifecycle'
```

Add useEffect for lifecycle initialization (after useYjsStore):
```typescript
// Initialize app lifecycle handlers for WebSocket reconnection (mobile)
useEffect(() => {
  if (provider) {
    initAppLifecycle(provider);
  }
  return () => {
    cleanupAppLifecycle();
  };
}, [provider]);
```

Add ConnectionBanner in render (after ConnectionIndicator):
```tsx
<ConnectionIndicator status={status} />
<ConnectionBanner status={status} />
```

3. Update `frontend/src/main.tsx` to initialize PWA elements:

Add at top (after configureStyles):
```typescript
// Initialize PWA elements for web camera fallback
import { defineCustomElements } from '@ionic/pwa-elements/loader';

// Only needed for web platform - native apps use native camera
if (typeof window !== 'undefined') {
  defineCustomElements(window);
}
```
  </action>
  <verify>
- `cat frontend/src/components/Canvas/ConnectionBanner.tsx` shows component
- `grep -n "ConnectionBanner" frontend/src/components/Canvas/Canvas.tsx` shows import and usage
- `grep -n "initAppLifecycle" frontend/src/components/Canvas/Canvas.tsx` shows lifecycle init
- `grep -n "pwa-elements" frontend/src/main.tsx` shows PWA elements init
- `npm run build` completes without errors
  </verify>
  <done>ConnectionBanner created and integrated with lifecycle handlers</done>
</task>

</tasks>

<verification>
1. `cat frontend/src/capacitor/lifecycle.ts` shows App.addListener calls
2. `cat frontend/src/capacitor/offline.ts` shows cacheBoard function
3. `cat frontend/src/components/Canvas/ConnectionBanner.tsx` shows component
4. `grep initAppLifecycle frontend/src/components/Canvas/Canvas.tsx` shows integration
5. `npm run build` completes without errors
</verification>

<success_criteria>
- Lifecycle handlers listen for appStateChange and resume events
- WebSocket provider reconnects when app returns from background
- Offline caching stores last 10 boards with Y.Doc state
- ConnectionBanner shows warning on disconnect, success on reconnect
- Success banner auto-dismisses after 2.5 seconds
- PWA elements initialized for web camera fallback
</success_criteria>

<output>
After completion, create `.planning/phases/08-mobile-platform/08-03-SUMMARY.md`
</output>
