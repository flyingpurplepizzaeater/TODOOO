---
phase: 02-canvas-foundation
plan: 04
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - frontend/src/components/Canvas/useYjsStore.ts
  - frontend/src/components/Canvas/useUndoManager.ts
  - frontend/src/components/Canvas/Canvas.tsx
  - frontend/src/components/Canvas/uiOverrides.ts
autonomous: true

must_haves:
  truths:
    - "User A's undo only reverts User A's changes"
    - "User B's undo only reverts User B's changes"
    - "Ctrl+Z triggers per-user undo, not global undo"
    - "Ctrl+Shift+Z triggers per-user redo"
    - "Per-user undo works across multiple browser windows"
  artifacts:
    - path: "frontend/src/components/Canvas/useUndoManager.ts"
      provides: "Per-user Yjs UndoManager hook"
      min_lines: 40
      exports: ["useUndoManager"]
  key_links:
    - from: "frontend/src/components/Canvas/Canvas.tsx"
      to: "frontend/src/components/Canvas/useUndoManager.ts"
      via: "hook import"
      pattern: "useUndoManager"
    - from: "frontend/src/components/Canvas/useUndoManager.ts"
      to: "Y.UndoManager"
      via: "Yjs UndoManager"
      pattern: "Y\\.UndoManager"
---

<objective>
Implement per-user undo/redo using Yjs UndoManager with trackedOrigins.

Purpose: CANV-04 requires that users can undo their own actions without affecting other users' history. This is critical for collaborative editing where User A undoing shouldn't remove User B's changes.

Output: Per-user undo/redo that tracks each client's changes independently.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-canvas-foundation/02-RESEARCH.md
@.planning/phases/02-canvas-foundation/02-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useUndoManager hook</name>
  <files>frontend/src/components/Canvas/useUndoManager.ts</files>
  <action>
Create a hook that provides per-user undo/redo using Yjs UndoManager:

Create frontend/src/components/Canvas/useUndoManager.ts:
```typescript
import { useEffect, useRef, useState } from 'react'
import * as Y from 'yjs'

export interface UndoManagerState {
  canUndo: boolean
  canRedo: boolean
  undo: () => void
  redo: () => void
}

/**
 * Per-user undo/redo using Yjs UndoManager with trackedOrigins.
 *
 * How it works:
 * 1. Each client has a unique clientId from Y.Doc
 * 2. UndoManager only tracks changes with that clientId as origin
 * 3. When User A undoes, only User A's changes are reverted
 * 4. User B's changes remain untouched
 *
 * From 02-RESEARCH.md:
 * - Use Yjs UndoManager with trackedOrigins scoped to clientId
 * - All local mutations must include clientId as transaction origin
 * - Override tldraw's Ctrl+Z/Y to use Yjs UndoManager instead
 */
export function useUndoManager(
  doc: Y.Doc | null,
  yArr: Y.Array<any> | null
): UndoManagerState {
  const undoManagerRef = useRef<Y.UndoManager | null>(null)
  const [canUndo, setCanUndo] = useState(false)
  const [canRedo, setCanRedo] = useState(false)

  useEffect(() => {
    if (!doc || !yArr) return

    // Create UndoManager scoped to this client's changes only
    const clientId = doc.clientID

    const undoManager = new Y.UndoManager(yArr, {
      // Only track changes made with this client's ID as origin
      trackedOrigins: new Set([clientId]),
      // Group changes within 500ms into single undo operation
      captureTimeout: 500,
    })

    undoManagerRef.current = undoManager

    // Update canUndo/canRedo state when stack changes
    const updateState = () => {
      setCanUndo(undoManager.canUndo())
      setCanRedo(undoManager.canRedo())
    }

    undoManager.on('stack-item-added', updateState)
    undoManager.on('stack-item-popped', updateState)
    undoManager.on('stack-cleared', updateState)

    return () => {
      undoManager.destroy()
      undoManagerRef.current = null
    }
  }, [doc, yArr])

  const undo = () => {
    undoManagerRef.current?.undo()
  }

  const redo = () => {
    undoManagerRef.current?.redo()
  }

  return { canUndo, canRedo, undo, redo }
}

/**
 * Helper to get clientId for transaction origins.
 * Use this when making changes that should be tracked by UndoManager.
 */
export function getClientId(doc: Y.Doc): number {
  return doc.clientID
}
```

Key implementation:
- trackedOrigins: new Set([clientId]) - only tracks this client's changes
- captureTimeout: 500 - groups rapid changes into single undo
- Stack event handlers update React state for UI
  </action>
  <verify>
- useUndoManager.ts exports useUndoManager and getClientId
- `npx tsc --noEmit` passes
  </verify>
  <done>
useUndoManager hook created with per-user tracking via clientId origin.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update useYjsStore to use client origin for transactions</name>
  <files>frontend/src/components/Canvas/useYjsStore.ts</files>
  <action>
Modify useYjsStore to:
1. Pass clientId as transaction origin for all local changes
2. Export doc and yArr refs for UndoManager hook

Update frontend/src/components/Canvas/useYjsStore.ts:

```typescript
import { useEffect, useMemo, useRef, useState } from 'react'
import { createTLStore, defaultShapeUtils, TLRecord, TLStoreWithStatus } from 'tldraw'
import * as Y from 'yjs'
import { YKeyValue } from 'y-utility/y-keyvalue'
import { createYjsProvider } from '../../lib/yjs/provider'

export type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error'

export interface YjsStoreResult {
  store: TLStoreWithStatus
  status: ConnectionStatus
  doc: Y.Doc | null
  yArr: Y.Array<{ key: string; val: TLRecord }> | null
}

export function useYjsStore(boardId: string, token: string): YjsStoreResult {
  const [store] = useState(() => createTLStore({ shapeUtils: defaultShapeUtils }))
  const [status, setStatus] = useState<ConnectionStatus>('connecting')

  // Refs for UndoManager access
  const docRef = useRef<Y.Doc | null>(null)
  const yArrRef = useRef<Y.Array<{ key: string; val: TLRecord }> | null>(null)

  useEffect(() => {
    const { doc, provider } = createYjsProvider(boardId, token)
    docRef.current = doc

    // Get clientId for transaction origins (enables per-user undo)
    const clientId = doc.clientID

    // Use Y.Array with YKeyValue for tldraw records
    const yArr = doc.getArray<{ key: string; val: TLRecord }>('tldraw')
    yArrRef.current = yArr
    const yStore = new YKeyValue(yArr)

    let isApplyingRemote = false

    // Sync Yjs -> tldraw (remote changes)
    const handleYjsChange = (events: Y.YEvent<any>[], transaction: Y.Transaction) => {
      // Skip if this is our own transaction (we already applied it locally)
      if (transaction.origin === clientId) return
      if (isApplyingRemote) return

      isApplyingRemote = true
      store.mergeRemoteChanges(() => {
        const records: TLRecord[] = []
        yStore.forEach((value) => {
          if (value) records.push(value)
        })

        const currentIds = new Set(store.allRecords().map(r => r.id))
        const newIds = new Set(records.map(r => r.id))

        currentIds.forEach(id => {
          if (!newIds.has(id)) {
            store.remove([id as any])
          }
        })

        store.put(records)
      })
      isApplyingRemote = false
    }

    yArr.observe(handleYjsChange)

    // Sync tldraw -> Yjs (local changes)
    // IMPORTANT: Use clientId as transaction origin for per-user undo tracking
    const unsub = store.listen(
      ({ changes }) => {
        if (isApplyingRemote) return

        // Pass clientId as origin so UndoManager tracks this change
        doc.transact(() => {
          Object.values(changes.added).forEach(record => {
            yStore.set(record.id, record)
          })
          Object.values(changes.updated).forEach(([, record]) => {
            yStore.set(record.id, record)
          })
          Object.values(changes.removed).forEach(record => {
            yStore.delete(record.id)
          })
        }, clientId)  // <-- clientId as transaction origin
      },
      { source: 'user', scope: 'document' }
    )

    // Connection status handling
    provider.on('status', ({ status: wsStatus }: { status: string }) => {
      if (wsStatus === 'connected') {
        setStatus('connected')
      } else if (wsStatus === 'disconnected') {
        setStatus('disconnected')
      }
    })

    provider.on('connection-error', () => {
      setStatus('error')
    })

    provider.on('sync', (synced: boolean) => {
      if (synced) {
        // Trigger initial sync - pass null origin for initial load
        const initRecords: TLRecord[] = []
        yStore.forEach((value) => {
          if (value) initRecords.push(value)
        })
        if (initRecords.length > 0) {
          store.mergeRemoteChanges(() => {
            store.put(initRecords)
          })
        }
      }
    })

    return () => {
      unsub()
      yArr.unobserve(handleYjsChange)
      provider.destroy()
      doc.destroy()
      docRef.current = null
      yArrRef.current = null
    }
  }, [boardId, token, store])

  return {
    store: store as TLStoreWithStatus,
    status,
    doc: docRef.current,
    yArr: yArrRef.current,
  }
}
```

Key changes:
- Added doc and yArr to return value for UndoManager
- Changed doc.transact(() => {...}, clientId) to include origin
- Skip handleYjsChange when transaction.origin === clientId (our own changes)
  </action>
  <verify>
- useYjsStore returns { store, status, doc, yArr }
- doc.transact has clientId as second argument
- `npx tsc --noEmit` passes
  </verify>
  <done>
useYjsStore updated to pass clientId as transaction origin for per-user undo tracking.
  </done>
</task>

<task type="auto">
  <name>Task 3: Override undo/redo shortcuts to use per-user UndoManager</name>
  <files>
    frontend/src/components/Canvas/uiOverrides.ts
    frontend/src/components/Canvas/Canvas.tsx
  </files>
  <action>
Override tldraw's Ctrl+Z/Y to use Yjs UndoManager instead of tldraw's global undo:

1. Update frontend/src/components/Canvas/uiOverrides.ts to accept undo/redo functions:

```typescript
import { TLUiOverrides, TLUiActionsContextType, TLUiToolsContextType } from 'tldraw'

/**
 * Create UI overrides with custom undo/redo handlers.
 *
 * We override tldraw's default undo/redo to use Yjs UndoManager,
 * which provides per-user undo history (CANV-04 requirement).
 */
export function createUiOverrides(
  customUndo: () => void,
  customRedo: () => void
): TLUiOverrides {
  return {
    actions(_editor, actions): TLUiActionsContextType {
      return {
        ...actions,
        // Override undo to use per-user Yjs UndoManager
        undo: {
          ...actions.undo,
          onSelect: () => {
            customUndo()
          },
        },
        // Override redo to use per-user Yjs UndoManager
        redo: {
          ...actions.redo,
          onSelect: () => {
            customRedo()
          },
        },
        // Bracket keys for zoom
        'zoom-in': {
          ...actions['zoom-in'],
          kbd: ']=,shift+='
        },
        'zoom-out': {
          ...actions['zoom-out'],
          kbd: '[-'
        },
      }
    },

    tools(_editor, tools): TLUiToolsContextType {
      return {
        ...tools,
        // Number keys for tools
        select: { ...tools.select, kbd: '1,v' },
        draw: { ...tools.draw, kbd: '2,p' },
        eraser: { ...tools.eraser, kbd: '3,e' },
        arrow: { ...tools.arrow, kbd: '4,a' },
        geo: { ...tools.geo, kbd: '5,r' },
      }
    },
  }
}

// Fallback static overrides (without custom undo/redo)
export const uiOverrides: TLUiOverrides = createUiOverrides(
  () => console.warn('Undo not connected'),
  () => console.warn('Redo not connected')
)
```

2. Update frontend/src/components/Canvas/Canvas.tsx to wire up UndoManager:

```typescript
import { useCallback, useMemo, useRef } from 'react'
import { Tldraw, Editor } from 'tldraw'
import 'tldraw/tldraw.css'
import { useYjsStore, ConnectionStatus } from './useYjsStore'
import { useUndoManager } from './useUndoManager'
import { cameraOptions, handleWheel } from './cameraOptions'
import { createUiOverrides } from './uiOverrides'

interface CanvasProps {
  boardId: string
  token: string
}

function ConnectionIndicator({ status }: { status: ConnectionStatus }) {
  const statusColors = {
    connecting: '#f59e0b',
    connected: '#22c55e',
    disconnected: '#ef4444',
    error: '#ef4444',
  }

  const statusLabels = {
    connecting: 'Connecting...',
    connected: 'Connected',
    disconnected: 'Disconnected',
    error: 'Connection Error',
  }

  return (
    <div style={{
      position: 'absolute',
      top: 8,
      right: 8,
      zIndex: 1000,
      display: 'flex',
      alignItems: 'center',
      gap: 6,
      padding: '4px 8px',
      borderRadius: 4,
      background: 'rgba(255,255,255,0.9)',
      fontSize: 12,
    }}>
      <div style={{
        width: 8,
        height: 8,
        borderRadius: '50%',
        background: statusColors[status],
      }} />
      {statusLabels[status]}
    </div>
  )
}

function UndoRedoIndicator({ canUndo, canRedo }: { canUndo: boolean; canRedo: boolean }) {
  return (
    <div style={{
      position: 'absolute',
      bottom: 8,
      right: 8,
      zIndex: 1000,
      display: 'flex',
      gap: 8,
      padding: '4px 8px',
      borderRadius: 4,
      background: 'rgba(255,255,255,0.9)',
      fontSize: 12,
    }}>
      <span style={{ color: canUndo ? '#333' : '#999' }}>
        Undo {canUndo ? '(Ctrl+Z)' : ''}
      </span>
      <span style={{ color: canRedo ? '#333' : '#999' }}>
        Redo {canRedo ? '(Ctrl+Shift+Z)' : ''}
      </span>
    </div>
  )
}

export function Canvas({ boardId, token }: CanvasProps) {
  const { store, status, doc, yArr } = useYjsStore(boardId, token)
  const { canUndo, canRedo, undo, redo } = useUndoManager(doc, yArr)
  const editorRef = useRef<Editor | null>(null)
  const containerRef = useRef<HTMLDivElement>(null)

  // Create UI overrides with per-user undo/redo
  const overrides = useMemo(
    () => createUiOverrides(undo, redo),
    [undo, redo]
  )

  const handleMount = useCallback((editor: Editor) => {
    editorRef.current = editor
    editor.user.updateUserPreferences({ isSnapMode: true })
  }, [])

  const onWheel = useCallback((e: React.WheelEvent) => {
    if (editorRef.current) {
      handleWheel(e.nativeEvent, editorRef.current)
    }
  }, [])

  return (
    <div
      ref={containerRef}
      style={{ position: 'fixed', inset: 0 }}
      onWheel={onWheel}
    >
      <ConnectionIndicator status={status} />
      <UndoRedoIndicator canUndo={canUndo} canRedo={canRedo} />
      <Tldraw
        store={store}
        cameraOptions={cameraOptions}
        overrides={overrides}
        onMount={handleMount}
        autoFocus
      />
    </div>
  )
}
```

Key integration:
- useUndoManager receives doc and yArr from useYjsStore
- createUiOverrides receives undo/redo functions
- UndoRedoIndicator shows undo/redo availability (optional visual feedback)
  </action>
  <verify>
1. TypeScript check: `npx tsc --noEmit`

2. Functional test (requires two browser windows with valid tokens):
   - User A draws shape, User A presses Ctrl+Z -> shape removed
   - User A draws shape, User B draws shape, User A presses Ctrl+Z -> only User A's shape removed
   - User B's shape remains
   - User A presses Ctrl+Shift+Z -> User A's shape restored
  </verify>
  <done>
Per-user undo/redo implemented via Yjs UndoManager with tldraw shortcut override.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Files exist:
   - frontend/src/components/Canvas/useUndoManager.ts
   - frontend/src/components/Canvas/useYjsStore.ts (updated)
   - frontend/src/components/Canvas/uiOverrides.ts (updated)
   - frontend/src/components/Canvas/Canvas.tsx (updated)

2. Type check passes:
   - `cd frontend && npx tsc --noEmit`

3. Per-user undo verification (with two browser windows):
   - Window 1 (User A) draws a rectangle
   - Window 2 (User B) draws a circle
   - Window 1 presses Ctrl+Z -> rectangle removed, circle remains
   - Window 2 presses Ctrl+Z -> circle removed, rectangle (if restored) remains
</verification>

<success_criteria>
- useUndoManager hook tracks per-user changes via clientId
- useYjsStore passes clientId as transaction origin
- Ctrl+Z triggers Yjs UndoManager (per-user), not tldraw undo (global)
- Two users can undo independently without affecting each other
</success_criteria>

<output>
After completion, create `.planning/phases/02-canvas-foundation/02-04-SUMMARY.md`
</output>
