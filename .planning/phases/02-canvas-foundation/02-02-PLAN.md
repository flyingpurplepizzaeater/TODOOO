---
phase: 02-canvas-foundation
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - frontend/package.json
  - frontend/src/App.tsx
  - frontend/src/components/Canvas/Canvas.tsx
  - frontend/src/components/Canvas/useYjsStore.ts
  - frontend/src/lib/yjs/provider.ts
autonomous: true

must_haves:
  truths:
    - "tldraw canvas renders in browser"
    - "Canvas connects to backend WebSocket at /ws/canvas/{board_id}"
    - "Drawing on canvas syncs to Yjs document"
    - "Two browser windows see each other's changes"
  artifacts:
    - path: "frontend/src/components/Canvas/Canvas.tsx"
      provides: "Tldraw wrapper component"
      min_lines: 30
    - path: "frontend/src/components/Canvas/useYjsStore.ts"
      provides: "Bidirectional Yjs-tldraw sync hook"
      min_lines: 60
      exports: ["useYjsStore"]
    - path: "frontend/src/lib/yjs/provider.ts"
      provides: "WebSocket provider setup"
      min_lines: 20
  key_links:
    - from: "frontend/src/components/Canvas/Canvas.tsx"
      to: "frontend/src/components/Canvas/useYjsStore.ts"
      via: "hook import"
      pattern: "import.*useYjsStore"
    - from: "frontend/src/components/Canvas/useYjsStore.ts"
      to: "frontend/src/lib/yjs/provider.ts"
      via: "provider import"
      pattern: "WebsocketProvider"
    - from: "frontend/src/lib/yjs/provider.ts"
      to: "/ws/canvas/{board_id}"
      via: "y-websocket connection"
      pattern: "WebsocketProvider"
---

<objective>
Integrate tldraw with Yjs synchronization to the backend WebSocket.

Purpose: This is the core integration that enables real-time collaborative canvas. tldraw provides the canvas UI, Yjs provides CRDT sync, and the backend WebSocket (Phase 1) provides persistence and broadcast.

Output: Working collaborative canvas that syncs changes between multiple browser windows via backend.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-canvas-foundation/02-RESEARCH.md
@.planning/phases/02-canvas-foundation/02-01-SUMMARY.md
@canvas/websocket_handler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install tldraw and Yjs dependencies</name>
  <files>frontend/package.json</files>
  <action>
Install the required packages for tldraw and Yjs integration:

```bash
cd frontend
npm install tldraw yjs y-websocket y-utility
```

Packages:
- `tldraw` - Canvas SDK (v4.2.x)
- `yjs` - CRDT library (v13.6.x)
- `y-websocket` - WebSocket provider for Yjs
- `y-utility` - YKeyValue helper for efficient key-value storage

Note: tldraw requires a license for production. For development, it works without a key. The "Made with tldraw" watermark appears in hobby/trial mode.

Do NOT install @tldraw/sync - we're using Yjs directly.
  </action>
  <verify>
- package.json includes tldraw, yjs, y-websocket, y-utility
- `npm ls tldraw` shows version 4.x
- `npm ls yjs` shows version 13.x
  </verify>
  <done>
tldraw and Yjs packages installed in frontend.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Yjs WebSocket provider and sync hook</name>
  <files>
    frontend/src/lib/yjs/provider.ts
    frontend/src/components/Canvas/useYjsStore.ts
  </files>
  <action>
Create the Yjs integration layer:

1. Create frontend/src/lib/yjs/provider.ts:
```typescript
import * as Y from 'yjs'
import { WebsocketProvider } from 'y-websocket'
import { config } from '../../config'

export function createYjsProvider(boardId: string, token: string) {
  const doc = new Y.Doc()

  // Connect to backend WebSocket with JWT token
  const wsUrl = `${config.wsUrl}/ws/canvas/${boardId}?token=${token}`

  const provider = new WebsocketProvider(
    wsUrl,
    boardId,
    doc,
    { connect: true }
  )

  return { doc, provider }
}
```

2. Create frontend/src/components/Canvas/useYjsStore.ts:
```typescript
import { useEffect, useMemo, useState } from 'react'
import { createTLStore, defaultShapeUtils, TLRecord, TLStoreWithStatus } from 'tldraw'
import * as Y from 'yjs'
import { YKeyValue } from 'y-utility/y-keyvalue'
import { createYjsProvider } from '../../lib/yjs/provider'

export type ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error'

export function useYjsStore(boardId: string, token: string): {
  store: TLStoreWithStatus
  status: ConnectionStatus
} {
  const [store] = useState(() => createTLStore({ shapeUtils: defaultShapeUtils }))
  const [status, setStatus] = useState<ConnectionStatus>('connecting')

  useEffect(() => {
    const { doc, provider } = createYjsProvider(boardId, token)

    // Use Y.Array with YKeyValue for tldraw records (prevents unbounded growth)
    const yArr = doc.getArray<{ key: string; val: TLRecord }>('tldraw')
    const yStore = new YKeyValue(yArr)

    // Track if we're applying remote changes (to prevent echo loops)
    let isApplyingRemote = false

    // Sync Yjs -> tldraw (remote changes)
    const handleYjsChange = () => {
      if (isApplyingRemote) return

      isApplyingRemote = true
      store.mergeRemoteChanges(() => {
        const records: TLRecord[] = []
        yStore.forEach((value) => {
          if (value) records.push(value)
        })

        // Get current store records to find deletions
        const currentIds = new Set(store.allRecords().map(r => r.id))
        const newIds = new Set(records.map(r => r.id))

        // Remove deleted records
        currentIds.forEach(id => {
          if (!newIds.has(id)) {
            store.remove([id as any])
          }
        })

        // Add/update records
        store.put(records)
      })
      isApplyingRemote = false
    }

    yArr.observe(handleYjsChange)

    // Sync tldraw -> Yjs (local changes)
    const unsub = store.listen(
      ({ changes }) => {
        if (isApplyingRemote) return

        doc.transact(() => {
          Object.values(changes.added).forEach(record => {
            yStore.set(record.id, record)
          })
          Object.values(changes.updated).forEach(([, record]) => {
            yStore.set(record.id, record)
          })
          Object.values(changes.removed).forEach(record => {
            yStore.delete(record.id)
          })
        })
      },
      { source: 'user', scope: 'document' }
    )

    // Connection status handling
    provider.on('status', ({ status: wsStatus }: { status: string }) => {
      if (wsStatus === 'connected') {
        setStatus('connected')
      } else if (wsStatus === 'disconnected') {
        setStatus('disconnected')
      }
    })

    provider.on('connection-error', () => {
      setStatus('error')
    })

    // Initial sync when connected
    provider.on('sync', (synced: boolean) => {
      if (synced) {
        handleYjsChange()
      }
    })

    return () => {
      unsub()
      yArr.unobserve(handleYjsChange)
      provider.destroy()
      doc.destroy()
    }
  }, [boardId, token, store])

  return {
    store: store as TLStoreWithStatus,
    status
  }
}
```

Key implementation details:
- Uses YKeyValue instead of Y.Map (prevents memory growth from research)
- Uses mergeRemoteChanges() to prevent echo loops (from research)
- Filters store.listen with { source: 'user' } to ignore remote changes
- Handles connection status for UI feedback
  </action>
  <verify>
- frontend/src/lib/yjs/provider.ts exists and exports createYjsProvider
- frontend/src/components/Canvas/useYjsStore.ts exists and exports useYjsStore
- `npx tsc --noEmit` passes (no type errors)
  </verify>
  <done>
Yjs provider and bidirectional sync hook created with echo loop prevention.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Canvas component with tldraw</name>
  <files>
    frontend/src/components/Canvas/Canvas.tsx
    frontend/src/components/Canvas/index.ts
    frontend/src/App.tsx
  </files>
  <action>
Create the Canvas component that renders tldraw with Yjs sync:

1. Create frontend/src/components/Canvas/Canvas.tsx:
```typescript
import { Tldraw, TLStoreWithStatus } from 'tldraw'
import 'tldraw/tldraw.css'
import { useYjsStore, ConnectionStatus } from './useYjsStore'

interface CanvasProps {
  boardId: string
  token: string
}

function ConnectionIndicator({ status }: { status: ConnectionStatus }) {
  const statusColors = {
    connecting: '#f59e0b',  // amber
    connected: '#22c55e',   // green
    disconnected: '#ef4444', // red
    error: '#ef4444',       // red
  }

  const statusLabels = {
    connecting: 'Connecting...',
    connected: 'Connected',
    disconnected: 'Disconnected',
    error: 'Connection Error',
  }

  return (
    <div style={{
      position: 'absolute',
      top: 8,
      right: 8,
      zIndex: 1000,
      display: 'flex',
      alignItems: 'center',
      gap: 6,
      padding: '4px 8px',
      borderRadius: 4,
      background: 'rgba(255,255,255,0.9)',
      fontSize: 12,
    }}>
      <div style={{
        width: 8,
        height: 8,
        borderRadius: '50%',
        background: statusColors[status],
      }} />
      {statusLabels[status]}
    </div>
  )
}

export function Canvas({ boardId, token }: CanvasProps) {
  const { store, status } = useYjsStore(boardId, token)

  return (
    <div style={{ position: 'fixed', inset: 0 }}>
      <ConnectionIndicator status={status} />
      <Tldraw
        store={store}
        autoFocus
      />
    </div>
  )
}
```

2. Create frontend/src/components/Canvas/index.ts:
```typescript
export { Canvas } from './Canvas'
export { useYjsStore } from './useYjsStore'
export type { ConnectionStatus } from './useYjsStore'
```

3. Update frontend/src/App.tsx to use Canvas (with hardcoded test values for now):
```typescript
import { Canvas } from './components/Canvas'

// TODO: These will come from routing/auth in later phases
const TEST_BOARD_ID = 'test-board-123'
const TEST_TOKEN = '' // Empty for now - backend will reject without valid token

function App() {
  // Show Canvas if we have a token, otherwise show setup instructions
  if (!TEST_TOKEN) {
    return (
      <div style={{
        position: 'fixed',
        inset: 0,
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        fontFamily: 'sans-serif',
        gap: 16,
        padding: 24,
        textAlign: 'center',
      }}>
        <h1>CollabBoard Canvas</h1>
        <p>Canvas is ready. To test sync:</p>
        <ol style={{ textAlign: 'left' }}>
          <li>Start backend: <code>uvicorn main:app --reload</code></li>
          <li>Create a board and get a JWT token via API</li>
          <li>Set TEST_TOKEN in App.tsx</li>
        </ol>
        <p style={{ color: '#666', marginTop: 16 }}>
          tldraw is installed and ready to render.
        </p>
      </div>
    )
  }

  return <Canvas boardId={TEST_BOARD_ID} token={TEST_TOKEN} />
}

export default App
```

Note: The Canvas requires a valid JWT token to connect. For local testing, the user needs to:
1. Start the backend
2. Get a token via /auth/login
3. Create a board via POST /boards
4. Update TEST_TOKEN and TEST_BOARD_ID
  </action>
  <verify>
- Canvas.tsx exists and imports tldraw
- `npm run dev` shows the setup instructions page
- Browser dev tools show no import errors
- tldraw.css styles are loaded (check network tab or styles)
  </verify>
  <done>
Canvas component created with tldraw and Yjs integration. Displays setup instructions until auth is configured.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Packages installed:
   - `npm ls tldraw yjs y-websocket y-utility` shows all packages

2. Files exist:
   - frontend/src/components/Canvas/Canvas.tsx
   - frontend/src/components/Canvas/useYjsStore.ts
   - frontend/src/lib/yjs/provider.ts

3. Type check passes:
   - `cd frontend && npx tsc --noEmit`

4. Dev server runs:
   - `npm run dev` shows app at http://localhost:5173

5. Manual sync test (requires backend running + valid token):
   - Set TEST_TOKEN and TEST_BOARD_ID in App.tsx
   - Open two browser windows to same URL
   - Draw in one window, appears in other
</verification>

<success_criteria>
- tldraw canvas renders in browser
- Yjs sync hook connects to backend WebSocket
- Connection status indicator shows current state
- TypeScript compilation succeeds
- Two browser windows (with valid tokens) sync drawings
</success_criteria>

<output>
After completion, create `.planning/phases/02-canvas-foundation/02-02-SUMMARY.md`
</output>
