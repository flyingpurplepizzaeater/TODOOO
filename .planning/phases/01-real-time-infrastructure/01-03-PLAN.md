---
phase: 01-real-time-infrastructure
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - canvas/room_manager.py
  - canvas/websocket_handler.py
  - canvas/__init__.py
  - main.py
autonomous: true

must_haves:
  truths:
    - "WebSocket endpoint accepts connections at /ws/canvas/{board_id}"
    - "JWT token validated before WebSocket accepts"
    - "Permission checked before allowing connection"
    - "Y.Doc state syncs between multiple connected clients"
    - "Room persists to database on changes (debounced)"
    - "Room unloads after 30 minutes of inactivity"
    - "Reconnecting client receives full current state (SYNC-05)"
  artifacts:
    - path: "canvas/room_manager.py"
      provides: "RoomManager class managing Y.Doc instances per board"
      contains: "class RoomManager"
    - path: "canvas/websocket_handler.py"
      provides: "WebSocket handler for Yjs sync protocol"
      contains: "async def handle_canvas_websocket"
    - path: "main.py"
      provides: "Canvas WebSocket endpoint registration"
      contains: "/ws/canvas/"
  key_links:
    - from: "canvas/room_manager.py"
      to: "canvas/persistence.py"
      via: "BoardPersistence import"
      pattern: "from .persistence import BoardPersistence"
    - from: "canvas/websocket_handler.py"
      to: "canvas/room_manager.py"
      via: "RoomManager import"
      pattern: "from .room_manager import"
    - from: "main.py"
      to: "canvas/websocket_handler.py"
      via: "handler import"
      pattern: "from canvas"
---

<objective>
Create room manager and WebSocket endpoint for real-time CRDT synchronization.

Purpose: Enables SYNC-03 (changes sync within 200ms) and SYNC-05 (auto-reconnection with full state sync) by implementing Yjs sync protocol over WebSocket with room-based document management.

Output: RoomManager class managing Y.Doc instances, WebSocket handler for Yjs protocol, canvas WebSocket endpoint in main.py.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-real-time-infrastructure/01-RESEARCH.md

# Prior plan outputs (will exist after Plan 01 and 02 complete)
# @.planning/phases/01-real-time-infrastructure/01-01-SUMMARY.md
# @.planning/phases/01-real-time-infrastructure/01-02-SUMMARY.md

# Existing codebase patterns
@main.py
@websocket.py
@auth.py
@models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RoomManager for Y.Doc lifecycle</name>
  <files>canvas/room_manager.py</files>
  <action>
Create canvas/room_manager.py with RoomManager class:

```python
"""
Room manager for CRDT document lifecycle.

Manages Y.Doc instances per board with:
- Lazy loading from persistence
- Automatic persistence on changes (debounced)
- Cleanup after inactivity
- Client tracking per room
"""
import asyncio
from datetime import datetime, timedelta
from typing import Optional
from pycrdt import Doc
from fastapi import WebSocket

from .persistence import BoardPersistence


class Room:
    """A single board room with its Y.Doc and connected clients."""

    def __init__(self, board_id: str, ydoc: Doc):
        self.board_id = board_id
        self.ydoc = ydoc
        self.clients: set[WebSocket] = set()
        self.last_activity = datetime.utcnow()

    def touch(self):
        """Update last activity timestamp."""
        self.last_activity = datetime.utcnow()


class RoomManager:
    """
    Manages Y.Doc rooms for canvas boards.

    Features:
    - Lazy load: Y.Doc created/loaded on first connection
    - Auto-persist: Changes saved to database (debounced)
    - Auto-cleanup: Rooms unloaded after inactivity
    - Reconnection support: New connections get full current state (SYNC-05)
    """

    INACTIVITY_TIMEOUT = timedelta(minutes=30)
    CLEANUP_INTERVAL = timedelta(minutes=5)

    def __init__(self, persistence: BoardPersistence):
        self._persistence = persistence
        self._rooms: dict[str, Room] = {}
        self._cleanup_task: Optional[asyncio.Task] = None

    async def start(self):
        """Start the background cleanup task."""
        self._cleanup_task = asyncio.create_task(self._cleanup_loop())

    async def stop(self):
        """Stop cleanup and flush pending persistence."""
        if self._cleanup_task:
            self._cleanup_task.cancel()
            try:
                await self._cleanup_task
            except asyncio.CancelledError:
                pass
        await self._persistence.flush_pending()

    async def get_or_create_room(self, board_id: str) -> Room:
        """
        Get existing room or create new one.

        Loads persisted state if available. This is how reconnection works:
        - If room is in memory, returns it with current state
        - If room was unloaded, loads from database (persistence layer)
        - New connections always get full current state (SYNC-05 compliance)

        Args:
            board_id: The board UUID

        Returns:
            Room instance with Y.Doc
        """
        if board_id in self._rooms:
            room = self._rooms[board_id]
            room.touch()
            return room

        # Create new Y.Doc
        ydoc = Doc()

        # Load persisted state if exists (enables reconnection to get full state)
        state = await self._persistence.load(board_id)
        if state:
            ydoc.apply_update(state)

        room = Room(board_id, ydoc)
        self._rooms[board_id] = room
        return room

    async def add_client(self, board_id: str, websocket: WebSocket) -> Room:
        """
        Add a client to a room.

        Args:
            board_id: The board UUID
            websocket: The client's WebSocket connection

        Returns:
            The room the client joined
        """
        room = await self.get_or_create_room(board_id)
        room.clients.add(websocket)
        room.touch()
        return room

    def remove_client(self, board_id: str, websocket: WebSocket):
        """
        Remove a client from a room.

        Args:
            board_id: The board UUID
            websocket: The client's WebSocket connection
        """
        if board_id in self._rooms:
            room = self._rooms[board_id]
            room.clients.discard(websocket)

    async def broadcast(self, board_id: str, data: bytes, exclude: Optional[WebSocket] = None):
        """
        Broadcast binary data to all clients in a room.

        Args:
            board_id: The board UUID
            data: Binary data to send
            exclude: Optional WebSocket to exclude from broadcast
        """
        if board_id not in self._rooms:
            return

        room = self._rooms[board_id]
        dead_clients = set()

        for client in room.clients:
            if client != exclude:
                try:
                    await client.send_bytes(data)
                except Exception:
                    dead_clients.add(client)

        # Clean up dead connections
        room.clients -= dead_clients

    async def apply_update(self, board_id: str, update: bytes, source: WebSocket):
        """
        Apply a Y.Doc update and broadcast to other clients.

        Args:
            board_id: The board UUID
            update: Binary Yjs update
            source: The WebSocket that sent the update
        """
        if board_id not in self._rooms:
            return

        room = self._rooms[board_id]
        room.ydoc.apply_update(update)
        room.touch()

        # Broadcast to other clients
        await self.broadcast(board_id, update, exclude=source)

        # Debounced persistence
        await self._persistence.save_debounced(board_id, room.ydoc)

    def get_state(self, board_id: str) -> Optional[bytes]:
        """
        Get current Y.Doc state for a room.

        Args:
            board_id: The board UUID

        Returns:
            Binary state or None if room doesn't exist
        """
        if board_id not in self._rooms:
            return None
        return self._rooms[board_id].ydoc.get_state()

    async def _cleanup_loop(self):
        """Background task to unload inactive rooms."""
        while True:
            await asyncio.sleep(self.CLEANUP_INTERVAL.total_seconds())

            now = datetime.utcnow()
            to_unload = []

            for board_id, room in self._rooms.items():
                # Only unload if no clients and inactive
                if not room.clients and (now - room.last_activity) > self.INACTIVITY_TIMEOUT:
                    to_unload.append(board_id)

            for board_id in to_unload:
                room = self._rooms.pop(board_id)
                # Final save before unloading
                await self._persistence.save(board_id, room.ydoc)
```
  </action>
  <verify>
cd "C:\Users\Workshop\Desktop\AI-2\Claude RW+skills\TODO" && python -c "from canvas.room_manager import RoomManager, Room; print('RoomManager imported successfully')"
  </verify>
  <done>
RoomManager and Room classes import without errors. RoomManager has get_or_create_room, add_client, remove_client, broadcast, apply_update methods.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WebSocket handler for Yjs sync protocol with reconnection support</name>
  <files>canvas/websocket_handler.py</files>
  <action>
Create canvas/websocket_handler.py:

```python
"""
WebSocket handler for canvas CRDT synchronization.

Implements Yjs sync protocol with SYNC-05 (auto-reconnection) support:
1. Client connects with JWT token
2. Server validates token and permissions
3. Server sends current Y.Doc state (sync step 1) - THIS IS THE RECONNECTION MECHANISM
4. Client sends its state (sync step 2)
5. Bidirectional updates flow until disconnect

On reconnection:
- Client disconnects (network issue, tab close, etc.)
- Client reconnects with same token
- Server sends FULL current state (from memory or loaded from DB)
- Client merges with its local state via CRDT
- No data loss due to CRDT merge semantics
"""
from fastapi import WebSocket, WebSocketDisconnect
from jose import JWTError, jwt
from sqlalchemy import select
from typing import Optional

from config import SECRET_KEY, ALGORITHM
from database import async_session
from models import User, Board, BoardPermission, PermissionLevel, AuditLog

from .room_manager import RoomManager


async def verify_canvas_access(
    token: str,
    board_id: str,
    request_ip: Optional[str] = None,
    user_agent: Optional[str] = None
) -> tuple[Optional[User], Optional[str]]:
    """
    Verify JWT token and board access permission.

    Args:
        token: JWT token from query params
        board_id: The board UUID
        request_ip: Client IP for audit log
        user_agent: Client user agent for audit log

    Returns:
        Tuple of (User or None, permission level or None)
    """
    # Decode token
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id = payload.get("sub")
        if user_id is None:
            return None, None
        user_id = int(user_id)
    except (JWTError, ValueError):
        return None, None

    async with async_session() as db:
        # Get user
        result = await db.execute(select(User).where(User.id == user_id))
        user = result.scalar_one_or_none()
        if not user:
            return None, None

        # Get board
        result = await db.execute(select(Board).where(Board.id == board_id))
        board = result.scalar_one_or_none()
        if not board:
            return None, None

        # Check permissions
        permission_level = None

        # Owner has full edit access
        if board.owner_id == user_id:
            permission_level = PermissionLevel.EDIT.value
        else:
            # Check explicit permission
            result = await db.execute(
                select(BoardPermission).where(
                    BoardPermission.board_id == board_id,
                    BoardPermission.user_id == user_id
                )
            )
            perm = result.scalar_one_or_none()
            if perm:
                permission_level = perm.level.value

            # Check public access if no explicit permission
            if not permission_level and board.is_public:
                result = await db.execute(
                    select(BoardPermission).where(
                        BoardPermission.board_id == board_id,
                        BoardPermission.user_id == None  # noqa: E711
                    )
                )
                public_perm = result.scalar_one_or_none()
                if public_perm:
                    permission_level = public_perm.level.value

        if not permission_level:
            return user, None

        # Log access for audit trail
        audit = AuditLog(
            user_id=user_id,
            board_id=board_id,
            action="access",
            permission_level=permission_level,
            ip_address=request_ip,
            user_agent=user_agent
        )
        db.add(audit)
        await db.commit()

        return user, permission_level


async def handle_canvas_websocket(
    websocket: WebSocket,
    board_id: str,
    token: str,
    room_manager: RoomManager
):
    """
    Handle WebSocket connection for canvas sync.

    Supports SYNC-05 (auto-reconnection):
    - On every connection (new or reconnect), sends full current state
    - Client CRDT merges server state with local state
    - Result: seamless reconnection with no data loss

    Args:
        websocket: FastAPI WebSocket
        board_id: The board UUID
        token: JWT token for authentication
        room_manager: The room manager instance
    """
    # Get client info for audit
    request_ip = None
    user_agent = None
    if hasattr(websocket, 'client') and websocket.client:
        request_ip = websocket.client.host
    if hasattr(websocket, 'headers'):
        user_agent = websocket.headers.get('user-agent')

    # Verify access
    user, permission = await verify_canvas_access(token, board_id, request_ip, user_agent)

    if not user:
        await websocket.close(code=4001)  # Unauthorized
        return

    if not permission:
        await websocket.close(code=4003)  # Forbidden
        return

    # Accept connection
    await websocket.accept()

    # Join room (loads state from DB if room was unloaded)
    room = await room_manager.add_client(board_id, websocket)

    # Send current state (sync step 1) - THIS IS THE RECONNECTION MECHANISM
    # Every connection (new or reconnect) receives full Y.Doc state
    # Client CRDT library merges with local state automatically
    state = room.ydoc.get_state()
    if state:
        await websocket.send_bytes(state)

    try:
        while True:
            # Receive Yjs update (binary)
            data = await websocket.receive_bytes()

            # Only apply updates if user has edit permission
            if permission == PermissionLevel.EDIT.value:
                await room_manager.apply_update(board_id, data, websocket)
            # View/comment users receive updates but can't send

    except WebSocketDisconnect:
        room_manager.remove_client(board_id, websocket)
```
  </action>
  <verify>
cd "C:\Users\Workshop\Desktop\AI-2\Claude RW+skills\TODO" && python -c "from canvas.websocket_handler import handle_canvas_websocket, verify_canvas_access; print('WebSocket handler imported successfully')"
  </verify>
  <done>
handle_canvas_websocket and verify_canvas_access functions import without errors. Handler validates JWT, checks permissions, logs access, manages Yjs sync protocol, and supports reconnection via full state sync.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register canvas WebSocket endpoint in main.py and update canvas __init__.py</name>
  <files>main.py, canvas/__init__.py</files>
  <action>
1. Update canvas/__init__.py to export all components:

```python
from .persistence import BoardPersistence
from .room_manager import RoomManager, Room
from .websocket_handler import handle_canvas_websocket, verify_canvas_access

__all__ = [
    "BoardPersistence",
    "RoomManager",
    "Room",
    "handle_canvas_websocket",
    "verify_canvas_access",
]
```

2. Update main.py to add canvas WebSocket endpoint:

At the top, add imports:
```python
from canvas import BoardPersistence, RoomManager, handle_canvas_websocket
```

In the lifespan context manager, after init_db():
```python
# Initialize canvas room manager
persistence = BoardPersistence(debounce_seconds=5.0)
room_manager = RoomManager(persistence)
await room_manager.start()
app.state.room_manager = room_manager
yield
# Cleanup on shutdown
await room_manager.stop()
```

Note: The yield statement needs to move AFTER room_manager setup, and cleanup happens after yield.

Add the WebSocket endpoint (after existing /ws/teams/{team_id} endpoint):

```python
@app.websocket("/ws/canvas/{board_id}")
async def canvas_websocket_endpoint(
    websocket: WebSocket,
    board_id: str,
    token: str = Query(...)
):
    """
    WebSocket endpoint for canvas CRDT synchronization.

    Implements Yjs sync protocol for real-time collaborative editing.
    Requires JWT token and board access permission.

    SYNC-05 compliance: Every connection receives full current state,
    enabling seamless reconnection after network issues.
    """
    await handle_canvas_websocket(
        websocket,
        board_id,
        token,
        websocket.app.state.room_manager
    )
```
  </action>
  <verify>
cd "C:\Users\Workshop\Desktop\AI-2\Claude RW+skills\TODO" && python -c "from main import app; print('main.py imports successfully'); print('Canvas endpoint registered:', '/ws/canvas/{board_id}' in [r.path for r in app.routes])"
  </verify>
  <done>
main.py loads without errors. Canvas WebSocket endpoint registered at /ws/canvas/{board_id}. RoomManager initialized in lifespan and cleaned up on shutdown.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `from canvas import RoomManager, BoardPersistence, handle_canvas_websocket` succeeds
2. `python -c "from main import app"` succeeds
3. /ws/canvas/{board_id} endpoint is registered in app routes
4. RoomManager creates rooms on demand and unloads after 30 min inactivity
5. WebSocket handler validates JWT and permissions before accepting
6. SYNC-05 reconnection: Connect -> disconnect -> reconnect -> client receives full state
</verification>

<success_criteria>
- RoomManager manages Y.Doc instances per board with lazy loading
- Rooms auto-persist on changes (debounced 5 seconds)
- Rooms unload after 30 minutes of inactivity
- WebSocket handler validates JWT token
- WebSocket handler checks board permissions
- WebSocket handler logs access to audit_logs table
- View/comment users can receive updates but not send
- Edit users can send and receive updates
- /ws/canvas/{board_id} endpoint accepts WebSocket connections
- Reconnecting client receives full current Y.Doc state (SYNC-05)
</success_criteria>

<output>
After completion, create `.planning/phases/01-real-time-infrastructure/01-03-SUMMARY.md`
</output>
