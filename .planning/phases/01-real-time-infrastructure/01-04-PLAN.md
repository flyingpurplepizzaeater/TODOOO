---
phase: 01-real-time-infrastructure
plan: 04
type: execute
wave: 4
depends_on: ["01-01", "01-03"]
files_modified:
  - routers/boards.py
  - routers/__init__.py
  - main.py
  - tests/test_boards.py
autonomous: true

must_haves:
  truths:
    - "User can create a new board via POST /boards"
    - "User can get their boards via GET /boards"
    - "Board owner can share board via POST /boards/{id}/share"
    - "Board owner can revoke permission via DELETE /boards/{id}/share/{user_id}"
    - "User can get shareable link via GET /boards/{id}/link"
    - "Board permissions validated before operations"
  artifacts:
    - path: "routers/boards.py"
      provides: "REST endpoints for board CRUD and sharing"
      contains: "router = APIRouter"
    - path: "tests/test_boards.py"
      provides: "Integration tests for board endpoints"
      contains: "def test_create_board"
  key_links:
    - from: "routers/boards.py"
      to: "models.py"
      via: "Board, BoardPermission imports"
      pattern: "from models import"
    - from: "routers/boards.py"
      to: "schemas.py"
      via: "BoardCreate, BoardResponse imports"
      pattern: "from schemas import"
    - from: "main.py"
      to: "routers/boards.py"
      via: "router include"
      pattern: "include_router.*boards"
---

<objective>
Create REST endpoints for board management and permission sharing.

Purpose: Enables SYNC-04 (shareable board links with team-based or public access) by providing endpoints to create boards, manage permissions, and generate shareable links.

Output: boards router with CRUD and sharing endpoints, integration tests, router registered in main.py.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-real-time-infrastructure/01-CONTEXT.md

# Prior plan outputs
# @.planning/phases/01-real-time-infrastructure/01-01-SUMMARY.md
# @.planning/phases/01-real-time-infrastructure/01-03-SUMMARY.md

# Existing codebase patterns
@routers/teams.py
@routers/auth.py
@tests/test_teams.py
@main.py
@schemas.py
@models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create boards router with CRUD endpoints</name>
  <files>routers/boards.py</files>
  <action>
Create routers/boards.py with board CRUD operations (create, list, get, delete).

Following patterns from routers/teams.py:

```python
"""
Board management endpoints.

Provides CRUD operations for boards and permission sharing.
"""
import uuid
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from database import get_db
from auth import get_current_user
from models import User, Board, BoardPermission, PermissionLevel, AuditLog
from schemas import (
    BoardCreate, BoardResponse,
    BoardPermissionCreate, BoardPermissionResponse,
    ShareLinkResponse
)

router = APIRouter(prefix="/boards", tags=["boards"])


@router.post("", response_model=BoardResponse, status_code=status.HTTP_201_CREATED)
async def create_board(
    board_data: BoardCreate,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create a new board."""
    board = Board(
        id=str(uuid.uuid4()),
        owner_id=user.id,
        title=board_data.title,
        is_public=board_data.is_public
    )
    db.add(board)

    # Log creation
    audit = AuditLog(
        user_id=user.id,
        board_id=board.id,
        action="create"
    )
    db.add(audit)

    await db.commit()
    await db.refresh(board)
    return board


@router.get("", response_model=list[BoardResponse])
async def list_boards(
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """List boards user owns or has access to."""
    # Get owned boards
    result = await db.execute(
        select(Board).where(Board.owner_id == user.id)
    )
    owned = result.scalars().all()

    # Get boards with explicit permission
    result = await db.execute(
        select(Board)
        .join(BoardPermission)
        .where(BoardPermission.user_id == user.id)
    )
    shared = result.scalars().all()

    # Combine and deduplicate
    board_ids = set()
    boards = []
    for board in list(owned) + list(shared):
        if board.id not in board_ids:
            boards.append(board)
            board_ids.add(board.id)

    return boards


@router.get("/{board_id}", response_model=BoardResponse)
async def get_board(
    board_id: str,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get a specific board."""
    result = await db.execute(select(Board).where(Board.id == board_id))
    board = result.scalar_one_or_none()

    if not board:
        raise HTTPException(status_code=404, detail="Board not found")

    # Check access
    if board.owner_id != user.id:
        result = await db.execute(
            select(BoardPermission).where(
                BoardPermission.board_id == board_id,
                BoardPermission.user_id == user.id
            )
        )
        if not result.scalar_one_or_none():
            # Check public access
            if not board.is_public:
                raise HTTPException(status_code=403, detail="Access denied")

    return board


@router.delete("/{board_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_board(
    board_id: str,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Delete a board. Only owner can delete."""
    result = await db.execute(select(Board).where(Board.id == board_id))
    board = result.scalar_one_or_none()

    if not board:
        raise HTTPException(status_code=404, detail="Board not found")

    if board.owner_id != user.id:
        raise HTTPException(status_code=403, detail="Only owner can delete board")

    # Log deletion
    audit = AuditLog(
        user_id=user.id,
        board_id=board_id,
        action="delete"
    )
    db.add(audit)

    await db.delete(board)
    await db.commit()
```
  </action>
  <verify>
cd "C:\Users\Workshop\Desktop\AI-2\Claude RW+skills\TODO" && python -c "from routers.boards import router; print('boards router imported successfully'); print('CRUD endpoints:', [r.path for r in router.routes if r.path in ['', '/{board_id}']])"
  </verify>
  <done>
boards router imports with CRUD endpoints: POST /boards, GET /boards, GET /boards/{board_id}, DELETE /boards/{board_id}.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add sharing and permission endpoints to boards router</name>
  <files>routers/boards.py</files>
  <action>
Add the sharing and permission endpoints to routers/boards.py (append to the file created in Task 1):

```python
@router.post("/{board_id}/share", response_model=BoardPermissionResponse, status_code=status.HTTP_201_CREATED)
async def share_board(
    board_id: str,
    perm_data: BoardPermissionCreate,
    request: Request,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Share board with a user or set public access."""
    result = await db.execute(select(Board).where(Board.id == board_id))
    board = result.scalar_one_or_none()

    if not board:
        raise HTTPException(status_code=404, detail="Board not found")

    if board.owner_id != user.id:
        raise HTTPException(status_code=403, detail="Only owner can share board")

    # Validate permission level
    try:
        level = PermissionLevel(perm_data.level)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid permission level")

    # Check if permission already exists
    if perm_data.user_id:
        result = await db.execute(
            select(BoardPermission).where(
                BoardPermission.board_id == board_id,
                BoardPermission.user_id == perm_data.user_id
            )
        )
    else:
        # Public permission
        result = await db.execute(
            select(BoardPermission).where(
                BoardPermission.board_id == board_id,
                BoardPermission.user_id == None  # noqa: E711
            )
        )

    existing = result.scalar_one_or_none()

    if existing:
        # Update existing permission
        existing.level = level
        perm = existing
    else:
        # Create new permission
        perm = BoardPermission(
            board_id=board_id,
            user_id=perm_data.user_id,
            level=level
        )
        db.add(perm)

    # Update is_public flag if this is public permission
    if perm_data.user_id is None:
        board.is_public = True

    # Log permission change
    audit = AuditLog(
        user_id=user.id,
        board_id=board_id,
        action="permission_change",
        permission_level=level.value,
        ip_address=request.client.host if request.client else None,
        user_agent=request.headers.get("user-agent")
    )
    db.add(audit)

    await db.commit()
    await db.refresh(perm)
    return perm


@router.delete("/{board_id}/share/{target_user_id}", status_code=status.HTTP_204_NO_CONTENT)
async def revoke_permission(
    board_id: str,
    target_user_id: int,
    request: Request,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Revoke a user's permission."""
    result = await db.execute(select(Board).where(Board.id == board_id))
    board = result.scalar_one_or_none()

    if not board:
        raise HTTPException(status_code=404, detail="Board not found")

    if board.owner_id != user.id:
        raise HTTPException(status_code=403, detail="Only owner can revoke permissions")

    result = await db.execute(
        select(BoardPermission).where(
            BoardPermission.board_id == board_id,
            BoardPermission.user_id == target_user_id
        )
    )
    perm = result.scalar_one_or_none()

    if not perm:
        raise HTTPException(status_code=404, detail="Permission not found")

    # Log revocation
    audit = AuditLog(
        user_id=user.id,
        board_id=board_id,
        action="permission_change",
        permission_level="revoked",
        ip_address=request.client.host if request.client else None,
        user_agent=request.headers.get("user-agent")
    )
    db.add(audit)

    await db.delete(perm)
    await db.commit()


@router.delete("/{board_id}/share/public", status_code=status.HTTP_204_NO_CONTENT)
async def revoke_public_access(
    board_id: str,
    request: Request,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Revoke public access to a board."""
    result = await db.execute(select(Board).where(Board.id == board_id))
    board = result.scalar_one_or_none()

    if not board:
        raise HTTPException(status_code=404, detail="Board not found")

    if board.owner_id != user.id:
        raise HTTPException(status_code=403, detail="Only owner can revoke permissions")

    result = await db.execute(
        select(BoardPermission).where(
            BoardPermission.board_id == board_id,
            BoardPermission.user_id == None  # noqa: E711
        )
    )
    perm = result.scalar_one_or_none()

    if perm:
        await db.delete(perm)

    board.is_public = False

    # Log revocation
    audit = AuditLog(
        user_id=user.id,
        board_id=board_id,
        action="permission_change",
        permission_level="public_revoked",
        ip_address=request.client.host if request.client else None,
        user_agent=request.headers.get("user-agent")
    )
    db.add(audit)

    await db.commit()


@router.get("/{board_id}/link", response_model=ShareLinkResponse)
async def get_share_link(
    board_id: str,
    request: Request,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get shareable link for a board."""
    result = await db.execute(select(Board).where(Board.id == board_id))
    board = result.scalar_one_or_none()

    if not board:
        raise HTTPException(status_code=404, detail="Board not found")

    # Only owner can get share link
    if board.owner_id != user.id:
        raise HTTPException(status_code=403, detail="Only owner can get share link")

    # Get public permission level if exists
    result = await db.execute(
        select(BoardPermission).where(
            BoardPermission.board_id == board_id,
            BoardPermission.user_id == None  # noqa: E711
        )
    )
    public_perm = result.scalar_one_or_none()

    # Construct base URL
    host = request.headers.get("host", "localhost:8000")
    scheme = request.headers.get("x-forwarded-proto", "http")
    base_url = f"{scheme}://{host}"

    return ShareLinkResponse(
        board_id=board_id,
        url=f"{base_url}/board/{board_id}",
        permission_level=public_perm.level.value if public_perm else "none",
        is_public=board.is_public
    )


@router.get("/{board_id}/permissions", response_model=list[BoardPermissionResponse])
async def list_permissions(
    board_id: str,
    user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """List all permissions for a board. Only owner can view."""
    result = await db.execute(select(Board).where(Board.id == board_id))
    board = result.scalar_one_or_none()

    if not board:
        raise HTTPException(status_code=404, detail="Board not found")

    if board.owner_id != user.id:
        raise HTTPException(status_code=403, detail="Only owner can view permissions")

    result = await db.execute(
        select(BoardPermission).where(BoardPermission.board_id == board_id)
    )
    return result.scalars().all()
```
  </action>
  <verify>
cd "C:\Users\Workshop\Desktop\AI-2\Claude RW+skills\TODO" && python -c "from routers.boards import router; print('All endpoints:', [r.path for r in router.routes])"
  </verify>
  <done>
boards router has all 9 endpoints: POST /boards, GET /boards, GET /boards/{id}, DELETE /boards/{id}, POST /boards/{id}/share, DELETE /boards/{id}/share/{user_id}, DELETE /boards/{id}/share/public, GET /boards/{id}/link, GET /boards/{id}/permissions.
  </done>
</task>

<task type="auto">
  <name>Task 3: Register boards router in main.py</name>
  <files>main.py, routers/__init__.py</files>
  <action>
1. Update routers/__init__.py to include boards:

Add to the imports:
```python
from . import boards
```

If __all__ exists, add "boards" to it.

2. Update main.py to include the boards router:

Add import at top:
```python
from routers import auth, teams, lists, todos, boards
```

Add after existing router includes:
```python
app.include_router(boards.router)
```
  </action>
  <verify>
cd "C:\Users\Workshop\Desktop\AI-2\Claude RW+skills\TODO" && python -c "from main import app; routes = [r.path for r in app.routes if hasattr(r, 'path')]; print('/boards' in str(routes) or '/boards/' in str(routes))"
  </verify>
  <done>
boards router registered in main.py. /boards endpoints accessible.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create integration tests for board endpoints</name>
  <files>tests/test_boards.py</files>
  <action>
Create tests/test_boards.py following patterns from tests/test_teams.py:

```python
"""
Integration tests for board endpoints.

Tests CRUD operations, permission sharing, and access control.
"""
import pytest
from httpx import AsyncClient
from main import app

pytestmark = pytest.mark.asyncio


class TestBoardCRUD:
    """Tests for board create, read, update, delete."""

    async def test_create_board(self, async_client: AsyncClient, auth_headers: dict):
        """User can create a board."""
        response = await async_client.post(
            "/boards",
            json={"title": "Test Board", "is_public": False},
            headers=auth_headers
        )
        assert response.status_code == 201
        data = response.json()
        assert data["title"] == "Test Board"
        assert data["is_public"] is False
        assert "id" in data

    async def test_create_board_default_title(self, async_client: AsyncClient, auth_headers: dict):
        """Board gets default title if not provided."""
        response = await async_client.post(
            "/boards",
            json={},
            headers=auth_headers
        )
        assert response.status_code == 201
        assert response.json()["title"] == "Untitled Board"

    async def test_list_boards(self, async_client: AsyncClient, auth_headers: dict):
        """User can list their boards."""
        # Create a board first
        await async_client.post(
            "/boards",
            json={"title": "My Board"},
            headers=auth_headers
        )

        response = await async_client.get("/boards", headers=auth_headers)
        assert response.status_code == 200
        boards = response.json()
        assert len(boards) >= 1
        assert any(b["title"] == "My Board" for b in boards)

    async def test_get_board(self, async_client: AsyncClient, auth_headers: dict):
        """User can get a specific board."""
        # Create board
        create_response = await async_client.post(
            "/boards",
            json={"title": "Specific Board"},
            headers=auth_headers
        )
        board_id = create_response.json()["id"]

        response = await async_client.get(f"/boards/{board_id}", headers=auth_headers)
        assert response.status_code == 200
        assert response.json()["title"] == "Specific Board"

    async def test_get_nonexistent_board(self, async_client: AsyncClient, auth_headers: dict):
        """Getting nonexistent board returns 404."""
        response = await async_client.get(
            "/boards/00000000-0000-0000-0000-000000000000",
            headers=auth_headers
        )
        assert response.status_code == 404

    async def test_delete_board(self, async_client: AsyncClient, auth_headers: dict):
        """Owner can delete board."""
        # Create board
        create_response = await async_client.post(
            "/boards",
            json={"title": "To Delete"},
            headers=auth_headers
        )
        board_id = create_response.json()["id"]

        response = await async_client.delete(f"/boards/{board_id}", headers=auth_headers)
        assert response.status_code == 204

        # Verify deleted
        get_response = await async_client.get(f"/boards/{board_id}", headers=auth_headers)
        assert get_response.status_code == 404


class TestBoardSharing:
    """Tests for board permission sharing."""

    async def test_share_board_with_user(
        self,
        async_client: AsyncClient,
        auth_headers: dict,
        second_user_id: int
    ):
        """Owner can share board with another user."""
        # Create board
        create_response = await async_client.post(
            "/boards",
            json={"title": "Shared Board"},
            headers=auth_headers
        )
        board_id = create_response.json()["id"]

        # Share with second user
        response = await async_client.post(
            f"/boards/{board_id}/share",
            json={"user_id": second_user_id, "level": "edit"},
            headers=auth_headers
        )
        assert response.status_code == 201
        assert response.json()["level"] == "edit"
        assert response.json()["user_id"] == second_user_id

    async def test_share_board_public(self, async_client: AsyncClient, auth_headers: dict):
        """Owner can make board public."""
        # Create board
        create_response = await async_client.post(
            "/boards",
            json={"title": "Public Board"},
            headers=auth_headers
        )
        board_id = create_response.json()["id"]

        # Make public with view permission
        response = await async_client.post(
            f"/boards/{board_id}/share",
            json={"user_id": None, "level": "view"},
            headers=auth_headers
        )
        assert response.status_code == 201
        assert response.json()["user_id"] is None
        assert response.json()["level"] == "view"

    async def test_revoke_permission(
        self,
        async_client: AsyncClient,
        auth_headers: dict,
        second_user_id: int
    ):
        """Owner can revoke user permission."""
        # Create and share board
        create_response = await async_client.post(
            "/boards",
            json={"title": "Revoke Test"},
            headers=auth_headers
        )
        board_id = create_response.json()["id"]

        await async_client.post(
            f"/boards/{board_id}/share",
            json={"user_id": second_user_id, "level": "edit"},
            headers=auth_headers
        )

        # Revoke
        response = await async_client.delete(
            f"/boards/{board_id}/share/{second_user_id}",
            headers=auth_headers
        )
        assert response.status_code == 204

    async def test_get_share_link(self, async_client: AsyncClient, auth_headers: dict):
        """Owner can get shareable link."""
        # Create board
        create_response = await async_client.post(
            "/boards",
            json={"title": "Link Board"},
            headers=auth_headers
        )
        board_id = create_response.json()["id"]

        response = await async_client.get(
            f"/boards/{board_id}/link",
            headers=auth_headers
        )
        assert response.status_code == 200
        data = response.json()
        assert data["board_id"] == board_id
        assert board_id in data["url"]

    async def test_list_permissions(self, async_client: AsyncClient, auth_headers: dict):
        """Owner can list all permissions."""
        # Create board and add permissions
        create_response = await async_client.post(
            "/boards",
            json={"title": "Permissions Board"},
            headers=auth_headers
        )
        board_id = create_response.json()["id"]

        # Add public permission
        await async_client.post(
            f"/boards/{board_id}/share",
            json={"user_id": None, "level": "view"},
            headers=auth_headers
        )

        response = await async_client.get(
            f"/boards/{board_id}/permissions",
            headers=auth_headers
        )
        assert response.status_code == 200
        perms = response.json()
        assert len(perms) >= 1


class TestBoardAccessControl:
    """Tests for board access control."""

    async def test_non_owner_cannot_delete(
        self,
        async_client: AsyncClient,
        auth_headers: dict,
        second_user_headers: dict
    ):
        """Non-owner cannot delete board."""
        # Create board as first user
        create_response = await async_client.post(
            "/boards",
            json={"title": "Protected Board"},
            headers=auth_headers
        )
        board_id = create_response.json()["id"]

        # Try to delete as second user
        response = await async_client.delete(
            f"/boards/{board_id}",
            headers=second_user_headers
        )
        assert response.status_code == 403

    async def test_non_owner_cannot_share(
        self,
        async_client: AsyncClient,
        auth_headers: dict,
        second_user_headers: dict
    ):
        """Non-owner cannot share board."""
        # Create board as first user
        create_response = await async_client.post(
            "/boards",
            json={"title": "Owner Only Share"},
            headers=auth_headers
        )
        board_id = create_response.json()["id"]

        # Try to share as second user
        response = await async_client.post(
            f"/boards/{board_id}/share",
            json={"user_id": None, "level": "view"},
            headers=second_user_headers
        )
        assert response.status_code == 403

    async def test_unauthenticated_cannot_access(self, async_client: AsyncClient):
        """Unauthenticated user cannot access boards."""
        response = await async_client.get("/boards")
        assert response.status_code == 401
```

Note: This test file requires fixtures from conftest.py. If `second_user_id`, `second_user_headers`, `async_client`, and `auth_headers` fixtures don't exist, they need to be added to conftest.py.
  </action>
  <verify>
cd "C:\Users\Workshop\Desktop\AI-2\Claude RW+skills\TODO" && python -m pytest tests/test_boards.py -v --collect-only 2>&1 | head -30
  </verify>
  <done>
test_boards.py created with tests collected. Tests cover board CRUD, sharing, and access control.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `from routers.boards import router` succeeds
2. `from main import app` succeeds with boards router included
3. `pytest tests/test_boards.py --collect-only` shows all test functions
4. POST /boards creates a board
5. GET /boards returns user's boards
6. POST /boards/{id}/share grants permission
7. DELETE /boards/{id}/share/{user_id} revokes permission
8. GET /boards/{id}/link returns shareable URL
</verification>

<success_criteria>
- POST /boards creates board with UUID, returns 201
- GET /boards lists owned and shared boards
- GET /boards/{id} returns board if user has access
- DELETE /boards/{id} deletes board (owner only)
- POST /boards/{id}/share grants permission (owner only)
- DELETE /boards/{id}/share/{user_id} revokes permission (owner only)
- DELETE /boards/{id}/share/public revokes public access
- GET /boards/{id}/link returns shareable URL
- GET /boards/{id}/permissions lists all permissions (owner only)
- All operations logged to audit_logs
- Tests cover CRUD, sharing, and access control
</success_criteria>

<output>
After completion, create `.planning/phases/01-real-time-infrastructure/01-04-SUMMARY.md`
</output>
