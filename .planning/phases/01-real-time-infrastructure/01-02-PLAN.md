---
phase: 01-real-time-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - canvas/__init__.py
  - canvas/persistence.py
  - alembic/versions/003_board_states.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "CRDT state can be saved to database as binary blob"
    - "CRDT state can be loaded from database"
    - "Persistence operations are async and non-blocking"
    - "Document compaction stores full state, not update log"
  artifacts:
    - path: "canvas/__init__.py"
      provides: "Canvas module initialization"
      min_lines: 1
    - path: "canvas/persistence.py"
      provides: "BoardPersistence class with save/load/delete methods"
      contains: "class BoardPersistence"
    - path: "alembic/versions/003_board_states.py"
      provides: "Migration for board_states table (CRDT binary storage)"
      contains: "def upgrade"
    - path: "requirements.txt"
      provides: "pycrdt and pycrdt-websocket dependencies"
      contains: "pycrdt"
  key_links:
    - from: "canvas/persistence.py"
      to: "database.py"
      via: "async_session import"
      pattern: "from database import"
    - from: "alembic/versions/003_board_states.py"
      to: "alembic/versions/002_canvas_boards.py"
      via: "down_revision reference"
      pattern: "down_revision"
---

<objective>
Create custom CRDT persistence layer for Y.Doc state using SQLite.

Purpose: Enables continuous persistence (CONTEXT.md requirement) by storing Y.Doc binary state to database. Custom implementation avoids SQLiteYStore unbounded growth pitfall identified in RESEARCH.md.

Output: BoardPersistence class that saves/loads Y.Doc state as compacted binary, plus pycrdt dependencies in requirements.txt, and separate migration for board_states table.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-real-time-infrastructure/01-RESEARCH.md

# Prior plan outputs (Plan 01 must complete first)
# @.planning/phases/01-real-time-infrastructure/01-01-SUMMARY.md

# Existing codebase patterns
@database.py
@requirements.txt
@alembic/versions/002_canvas_boards.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pycrdt dependencies to requirements.txt</name>
  <files>requirements.txt</files>
  <action>
Add these lines to requirements.txt (at the end):

```
pycrdt>=0.10.0
pycrdt-websocket>=0.16.0
```

These are the core CRDT libraries identified in RESEARCH.md:
- pycrdt: Python Yjs bindings (Rust-based, replaced archived ypy)
- pycrdt-websocket: WebSocket server for Yjs sync protocol

Note: aiosqlite is already in requirements.txt (0.19.0), so no need to add it.
  </action>
  <verify>
cd "C:\Users\Workshop\Desktop\AI-2\Claude RW+skills\TODO" && pip install pycrdt pycrdt-websocket --quiet && python -c "from pycrdt import Doc; print('pycrdt imported successfully')"
  </verify>
  <done>
pycrdt and pycrdt-websocket install without errors. pycrdt.Doc can be imported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create canvas module with persistence layer</name>
  <files>canvas/__init__.py, canvas/persistence.py</files>
  <action>
1. Create directory: canvas/

2. Create canvas/__init__.py:
```python
from .persistence import BoardPersistence

__all__ = ["BoardPersistence"]
```

3. Create canvas/persistence.py with BoardPersistence class:

```python
"""
Custom CRDT persistence layer.

Stores Y.Doc state as compacted binary blobs, avoiding the unbounded growth
issue of pycrdt-websocket's default SQLiteYStore (which logs all updates).

Design note: Uses raw SQL instead of ORM for board_states table because:
- board_states is a simple key-value store (board_id -> binary blob)
- No relationships, no complex queries, no joins needed
- Binary BLOB handling is more direct with raw SQL
- This is intentional, not a missing model
"""
from datetime import datetime
from typing import Optional
import asyncio
from pycrdt import Doc
from database import async_session

class BoardPersistence:
    """
    Persistence layer for Y.Doc state.

    Stores compacted document state (not update log) to avoid
    unbounded database growth.
    """

    def __init__(self, debounce_seconds: float = 5.0):
        """
        Args:
            debounce_seconds: Minimum time between saves for same board
        """
        self._debounce_seconds = debounce_seconds
        self._pending_saves: dict[str, asyncio.Task] = {}

    async def load(self, board_id: str) -> Optional[bytes]:
        """
        Load Y.Doc state from database.

        Args:
            board_id: The board UUID

        Returns:
            Binary Y.Doc state or None if board has no saved state
        """
        async with async_session() as session:
            result = await session.execute(
                "SELECT state FROM board_states WHERE board_id = :board_id",
                {"board_id": board_id}
            )
            row = result.fetchone()
            return row[0] if row else None

    async def save(self, board_id: str, ydoc: Doc) -> None:
        """
        Save compacted Y.Doc state to database.

        Stores full state vector, not incremental updates.
        This prevents unbounded growth of the state table.

        Args:
            board_id: The board UUID
            ydoc: The Y.Doc to persist
        """
        state = ydoc.get_state()

        async with async_session() as session:
            # Upsert: insert or replace existing state
            await session.execute(
                """
                INSERT INTO board_states (board_id, state, updated_at)
                VALUES (:board_id, :state, :updated_at)
                ON CONFLICT(board_id) DO UPDATE SET
                    state = excluded.state,
                    updated_at = excluded.updated_at
                """,
                {
                    "board_id": board_id,
                    "state": state,
                    "updated_at": datetime.utcnow()
                }
            )
            await session.commit()

    async def save_debounced(self, board_id: str, ydoc: Doc) -> None:
        """
        Save with debouncing to reduce database writes.

        If called multiple times within debounce_seconds, only the
        last call actually writes to database.

        Args:
            board_id: The board UUID
            ydoc: The Y.Doc to persist
        """
        # Cancel existing pending save for this board
        if board_id in self._pending_saves:
            self._pending_saves[board_id].cancel()

        async def delayed_save():
            await asyncio.sleep(self._debounce_seconds)
            await self.save(board_id, ydoc)
            self._pending_saves.pop(board_id, None)

        self._pending_saves[board_id] = asyncio.create_task(delayed_save())

    async def delete(self, board_id: str) -> None:
        """
        Delete persisted state for a board.

        Args:
            board_id: The board UUID
        """
        async with async_session() as session:
            await session.execute(
                "DELETE FROM board_states WHERE board_id = :board_id",
                {"board_id": board_id}
            )
            await session.commit()

    async def flush_pending(self) -> None:
        """
        Force all pending debounced saves to complete.

        Useful for graceful shutdown.
        """
        for task in self._pending_saves.values():
            task.cancel()
        self._pending_saves.clear()
```
  </action>
  <verify>
cd "C:\Users\Workshop\Desktop\AI-2\Claude RW+skills\TODO" && python -c "from canvas import BoardPersistence; print('BoardPersistence imported successfully')"
  </verify>
  <done>
BoardPersistence class imports without errors. Has load, save, save_debounced, delete, and flush_pending methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create separate migration for board_states table</name>
  <files>alembic/versions/003_board_states.py</files>
  <action>
Create a NEW migration file alembic/versions/003_board_states.py (separate from 002_canvas_boards.py which was created by Plan 01).

This avoids the race condition of multiple plans modifying the same migration file.

```python
"""
Board states table for CRDT binary storage.

Revision ID: [generate with secrets.token_hex(6)]
Revises: [ID from 002_canvas_boards.py]
Create Date: [current date]
"""
from alembic import op
import sqlalchemy as sa

# revision identifiers
revision = '[generate new ID]'
down_revision = '[ID from 002_canvas_boards.py]'
branch_labels = None
depends_on = None


def upgrade():
    # Board state storage (CRDT binary blobs)
    # Uses raw key-value storage, not ORM - see persistence.py for rationale
    op.create_table(
        'board_states',
        sa.Column('board_id', sa.String(36), sa.ForeignKey('boards.id', ondelete='CASCADE'), primary_key=True),
        sa.Column('state', sa.LargeBinary, nullable=False),
        sa.Column('updated_at', sa.DateTime, nullable=False)
    )


def downgrade():
    op.drop_table('board_states')
```

To get the correct down_revision:
1. Read alembic/versions/002_canvas_boards.py
2. Find its `revision = 'xxx'` value
3. Use that value as down_revision in this file
4. Generate a new revision ID with: python -c "import secrets; print(secrets.token_hex(6))"
  </action>
  <verify>
cd "C:\Users\Workshop\Desktop\AI-2\Claude RW+skills\TODO" && python -m alembic upgrade head && python -c "
import sqlite3
conn = sqlite3.connect('todo.db')
cursor = conn.cursor()
cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='board_states'\")
result = cursor.fetchone()
print('board_states table exists' if result else 'board_states table NOT found')
conn.close()
"
  </verify>
  <done>
board_states table exists in database with board_id (PK), state (BLOB), and updated_at columns. Migration chain: 001 -> 002 -> 003.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pip install -r requirements.txt` installs pycrdt and pycrdt-websocket
2. `from canvas import BoardPersistence` imports successfully
3. `from pycrdt import Doc` imports successfully
4. `alembic upgrade head` runs all three migrations in order
5. board_states table exists in database
6. BoardPersistence.save() stores binary data
7. BoardPersistence.load() retrieves binary data
</verification>

<success_criteria>
- pycrdt>=0.10.0 and pycrdt-websocket>=0.16.0 in requirements.txt
- canvas/ directory exists with __init__.py and persistence.py
- BoardPersistence class has async load(), save(), save_debounced(), delete(), flush_pending() methods
- 003_board_states.py migration created (separate from 002_canvas_boards.py)
- board_states table created with board_id primary key and state BLOB column
- Persistence stores compacted state (Doc.get_state()), not update log
</success_criteria>

<output>
After completion, create `.planning/phases/01-real-time-infrastructure/01-02-SUMMARY.md`
</output>
