---
phase: 01-real-time-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - canvas/__init__.py
  - canvas/persistence.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "CRDT state can be saved to database as binary blob"
    - "CRDT state can be loaded from database"
    - "Persistence operations are async and non-blocking"
    - "Document compaction stores full state, not update log"
  artifacts:
    - path: "canvas/__init__.py"
      provides: "Canvas module initialization"
      min_lines: 1
    - path: "canvas/persistence.py"
      provides: "BoardPersistence class with save/load/delete methods"
      contains: "class BoardPersistence"
    - path: "requirements.txt"
      provides: "pycrdt and pycrdt-websocket dependencies"
      contains: "pycrdt"
  key_links:
    - from: "canvas/persistence.py"
      to: "database.py"
      via: "async_session import"
      pattern: "from database import"
---

<objective>
Create custom CRDT persistence layer for Y.Doc state using SQLite.

Purpose: Enables continuous persistence (CONTEXT.md requirement) by storing Y.Doc binary state to database. Custom implementation avoids SQLiteYStore unbounded growth pitfall identified in RESEARCH.md.

Output: BoardPersistence class that saves/loads Y.Doc state as compacted binary, plus pycrdt dependencies in requirements.txt.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-real-time-infrastructure/01-RESEARCH.md

# Existing codebase patterns
@database.py
@requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pycrdt dependencies to requirements.txt</name>
  <files>requirements.txt</files>
  <action>
Add these lines to requirements.txt (at the end):

```
pycrdt>=0.10.0
pycrdt-websocket>=0.16.0
```

These are the core CRDT libraries identified in RESEARCH.md:
- pycrdt: Python Yjs bindings (Rust-based, replaced archived ypy)
- pycrdt-websocket: WebSocket server for Yjs sync protocol

Note: aiosqlite is already in requirements.txt (0.19.0), so no need to add it.
  </action>
  <verify>
cd "C:\Users\Workshop\Desktop\AI-2\Claude RW+skills\TODO" && pip install pycrdt pycrdt-websocket --quiet && python -c "from pycrdt import Doc; print('pycrdt imported successfully')"
  </verify>
  <done>
pycrdt and pycrdt-websocket install without errors. pycrdt.Doc can be imported.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create canvas module with persistence layer</name>
  <files>canvas/__init__.py, canvas/persistence.py</files>
  <action>
1. Create directory: canvas/

2. Create canvas/__init__.py:
```python
from .persistence import BoardPersistence

__all__ = ["BoardPersistence"]
```

3. Create canvas/persistence.py with BoardPersistence class:

```python
"""
Custom CRDT persistence layer.

Stores Y.Doc state as compacted binary blobs, avoiding the unbounded growth
issue of pycrdt-websocket's default SQLiteYStore (which logs all updates).
"""
from datetime import datetime
from typing import Optional
import asyncio
from pycrdt import Doc
from database import async_session

class BoardPersistence:
    """
    Persistence layer for Y.Doc state.

    Stores compacted document state (not update log) to avoid
    unbounded database growth.
    """

    def __init__(self, debounce_seconds: float = 5.0):
        """
        Args:
            debounce_seconds: Minimum time between saves for same board
        """
        self._debounce_seconds = debounce_seconds
        self._pending_saves: dict[str, asyncio.Task] = {}

    async def load(self, board_id: str) -> Optional[bytes]:
        """
        Load Y.Doc state from database.

        Args:
            board_id: The board UUID

        Returns:
            Binary Y.Doc state or None if board has no saved state
        """
        async with async_session() as session:
            result = await session.execute(
                "SELECT state FROM board_states WHERE board_id = :board_id",
                {"board_id": board_id}
            )
            row = result.fetchone()
            return row[0] if row else None

    async def save(self, board_id: str, ydoc: Doc) -> None:
        """
        Save compacted Y.Doc state to database.

        Stores full state vector, not incremental updates.
        This prevents unbounded growth of the state table.

        Args:
            board_id: The board UUID
            ydoc: The Y.Doc to persist
        """
        state = ydoc.get_state()

        async with async_session() as session:
            # Upsert: insert or replace existing state
            await session.execute(
                """
                INSERT INTO board_states (board_id, state, updated_at)
                VALUES (:board_id, :state, :updated_at)
                ON CONFLICT(board_id) DO UPDATE SET
                    state = excluded.state,
                    updated_at = excluded.updated_at
                """,
                {
                    "board_id": board_id,
                    "state": state,
                    "updated_at": datetime.utcnow()
                }
            )
            await session.commit()

    async def save_debounced(self, board_id: str, ydoc: Doc) -> None:
        """
        Save with debouncing to reduce database writes.

        If called multiple times within debounce_seconds, only the
        last call actually writes to database.

        Args:
            board_id: The board UUID
            ydoc: The Y.Doc to persist
        """
        # Cancel existing pending save for this board
        if board_id in self._pending_saves:
            self._pending_saves[board_id].cancel()

        async def delayed_save():
            await asyncio.sleep(self._debounce_seconds)
            await self.save(board_id, ydoc)
            self._pending_saves.pop(board_id, None)

        self._pending_saves[board_id] = asyncio.create_task(delayed_save())

    async def delete(self, board_id: str) -> None:
        """
        Delete persisted state for a board.

        Args:
            board_id: The board UUID
        """
        async with async_session() as session:
            await session.execute(
                "DELETE FROM board_states WHERE board_id = :board_id",
                {"board_id": board_id}
            )
            await session.commit()

    async def flush_pending(self) -> None:
        """
        Force all pending debounced saves to complete.

        Useful for graceful shutdown.
        """
        for task in self._pending_saves.values():
            task.cancel()
        self._pending_saves.clear()
```

Note: The board_states table will be created in the migration (Plan 01 creates the models, but we need to add board_states table to store binary CRDT state separately from the Board model metadata).
  </action>
  <verify>
cd "C:\Users\Workshop\Desktop\AI-2\Claude RW+skills\TODO" && python -c "from canvas import BoardPersistence; print('BoardPersistence imported successfully')"
  </verify>
  <done>
BoardPersistence class imports without errors. Has load, save, save_debounced, delete, and flush_pending methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add board_states table to migration</name>
  <files>alembic/versions/002_canvas_boards.py</files>
  <action>
This task depends on Plan 01 Task 3 having created the migration file. If the file doesn't exist yet, create it. If it exists, add the board_states table.

Add to the upgrade() function in 002_canvas_boards.py:

```python
# Board state storage (CRDT binary blobs)
op.create_table(
    'board_states',
    sa.Column('board_id', sa.String(36), sa.ForeignKey('boards.id', ondelete='CASCADE'), primary_key=True),
    sa.Column('state', sa.LargeBinary, nullable=False),
    sa.Column('updated_at', sa.DateTime, nullable=False)
)
```

Add to downgrade() function (before dropping boards table):
```python
op.drop_table('board_states')
```

The board_states table uses board_id as primary key (one state per board), stores binary CRDT state, and cascades delete when board is deleted.
  </action>
  <verify>
cd "C:\Users\Workshop\Desktop\AI-2\Claude RW+skills\TODO" && python -c "
import sqlite3
conn = sqlite3.connect('todo.db')
cursor = conn.cursor()
cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name='board_states'\")
result = cursor.fetchone()
print('board_states table exists' if result else 'board_states table NOT found')
conn.close()
"
  </verify>
  <done>
board_states table exists in database with board_id (PK), state (BLOB), and updated_at columns.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `pip install -r requirements.txt` installs pycrdt and pycrdt-websocket
2. `from canvas import BoardPersistence` imports successfully
3. `from pycrdt import Doc` imports successfully
4. board_states table exists in database
5. BoardPersistence.save() stores binary data
6. BoardPersistence.load() retrieves binary data
</verification>

<success_criteria>
- pycrdt>=0.10.0 and pycrdt-websocket>=0.16.0 in requirements.txt
- canvas/ directory exists with __init__.py and persistence.py
- BoardPersistence class has async load(), save(), save_debounced(), delete(), flush_pending() methods
- board_states table created with board_id primary key and state BLOB column
- Persistence stores compacted state (Doc.get_state()), not update log
</success_criteria>

<output>
After completion, create `.planning/phases/01-real-time-infrastructure/01-02-SUMMARY.md`
</output>
