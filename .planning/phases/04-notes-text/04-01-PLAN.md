---
phase: 04-notes-text
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/components/Canvas/styleConfig.ts
  - frontend/src/components/Canvas/noteColorPersistence.ts
  - frontend/src/components/Canvas/Canvas.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can add sticky notes via toolbar"
    - "User can choose from 6-8 sticky note colors"
    - "Sticky notes have subtle drop shadow like real Post-its"
    - "User can resize notes while maintaining square aspect ratio"
    - "User can add standalone text objects via toolbar"
    - "Double-click on note or text enters inline edit mode"
    - "Last-used note color persists across browser sessions"
  artifacts:
    - path: "frontend/src/components/Canvas/styleConfig.ts"
      provides: "Note color palette configuration"
      contains: "noteFill"
    - path: "frontend/src/components/Canvas/noteColorPersistence.ts"
      provides: "localStorage persistence for note color"
      exports: ["saveNoteColor", "restoreNoteColor", "NOTE_COLOR_KEY"]
    - path: "frontend/src/components/Canvas/Canvas.tsx"
      provides: "Note resize mode and color restoration"
      contains: "resizeMode"
  key_links:
    - from: "frontend/src/main.tsx"
      to: "styleConfig.ts"
      via: "configureStyles() call before React mount"
      pattern: "configureStyles\\(\\)"
    - from: "frontend/src/components/Canvas/Canvas.tsx"
      to: "noteColorPersistence.ts"
      via: "import and call in handleMount"
      pattern: "restoreNoteColor"
---

<objective>
Configure tldraw's built-in note and text shapes with custom sticky note colors, aspect-locked resize, and color persistence.

Purpose: Enable users to add sticky notes and text to the canvas with a professional Post-it appearance and remembered preferences.
Output: Updated styleConfig.ts with note colors, new noteColorPersistence.ts module, updated Canvas.tsx with note configuration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-notes-text/04-CONTEXT.md
@.planning/phases/04-notes-text/04-RESEARCH.md
@frontend/src/components/Canvas/styleConfig.ts
@frontend/src/components/Canvas/Canvas.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure sticky note colors in styleConfig.ts</name>
  <files>frontend/src/components/Canvas/styleConfig.ts</files>
  <action>
Add note fill and text colors to configureStyles() function. This extends the existing pattern of mutating DefaultColorThemePalette before React mounts.

Per CONTEXT.md: 6-8 colors with classic Post-it look. Use these colors that map to existing color keys:
- yellow (classic Post-it yellow) - default
- light-red (pink)
- light-blue (sky blue)
- light-green (mint green)
- orange
- violet (purple)
- light-violet (lavender)
- white (plain white option)

For each color, set both noteFill (background) and noteText (text color - typically black for readability):

```typescript
// Note colors - Light Mode
DefaultColorThemePalette.lightMode.yellow.noteFill = '#FEF3C7'      // warm yellow
DefaultColorThemePalette.lightMode.yellow.noteText = '#1a1a2e'
DefaultColorThemePalette.lightMode['light-red'].noteFill = '#FECACA' // soft pink
DefaultColorThemePalette.lightMode['light-red'].noteText = '#1a1a2e'
DefaultColorThemePalette.lightMode['light-blue'].noteFill = '#BFDBFE' // sky blue
DefaultColorThemePalette.lightMode['light-blue'].noteText = '#1a1a2e'
DefaultColorThemePalette.lightMode['light-green'].noteFill = '#BBF7D0' // mint
DefaultColorThemePalette.lightMode['light-green'].noteText = '#1a1a2e'
DefaultColorThemePalette.lightMode.orange.noteFill = '#FED7AA'       // peach
DefaultColorThemePalette.lightMode.orange.noteText = '#1a1a2e'
DefaultColorThemePalette.lightMode.violet.noteFill = '#DDD6FE'       // lavender
DefaultColorThemePalette.lightMode.violet.noteText = '#1a1a2e'
DefaultColorThemePalette.lightMode['light-violet'].noteFill = '#E9D5FF' // light purple
DefaultColorThemePalette.lightMode['light-violet'].noteText = '#1a1a2e'
DefaultColorThemePalette.lightMode.white.noteFill = '#FFFFFF'        // plain white
DefaultColorThemePalette.lightMode.white.noteText = '#1a1a2e'
```

Add corresponding dark mode versions (slightly adjusted for visibility on dark backgrounds).

Update the module JSDoc to mention note colors are also configured.
  </action>
  <verify>TypeScript compiles without errors: `cd frontend && npx tsc --noEmit`</verify>
  <done>styleConfig.ts exports configureStyles() that sets noteFill and noteText for 8 colors in both light and dark modes.</done>
</task>

<task type="auto">
  <name>Task 2: Create note color persistence module</name>
  <files>frontend/src/components/Canvas/noteColorPersistence.ts</files>
  <action>
Create new module to persist last-used sticky note color to localStorage.

Per RESEARCH.md: tldraw's stylesForNextShape doesn't persist across sessions, so we need localStorage.

Create noteColorPersistence.ts with:

1. Constants:
   - NOTE_COLOR_KEY = 'collabboard:note-color'
   - DEFAULT_NOTE_COLOR = 'yellow' (classic Post-it default)

2. saveNoteColor(color: string): void
   - Saves color key to localStorage

3. restoreNoteColor(editor: Editor): void
   - Reads from localStorage
   - If found, calls editor.setStyleForNextShapes(DefaultColorStyle, savedColor)
   - Import DefaultColorStyle from 'tldraw'

4. createNoteColorListener(editor: Editor): () => void
   - Returns unsubscribe function
   - Uses editor.store.listen with source:'user'
   - Watches for instance_state changes to stylesForNextShape
   - When color changes, calls saveNoteColor()
   - Pattern from RESEARCH.md:
     ```typescript
     editor.store.listen(
       (entry) => {
         if (entry.changes.updated['instance:instance_state']) {
           const updated = entry.changes.updated['instance:instance_state']
           const newStyles = updated[1]?.stylesForNextShape
           const noteColor = newStyles?.['tldraw:color']
           if (noteColor) {
             saveNoteColor(noteColor)
           }
         }
       },
       { source: 'user' }
     )
     ```

Export all functions and constants.
  </action>
  <verify>TypeScript compiles: `cd frontend && npx tsc --noEmit`</verify>
  <done>noteColorPersistence.ts exports saveNoteColor, restoreNoteColor, createNoteColorListener, NOTE_COLOR_KEY.</done>
</task>

<task type="auto">
  <name>Task 3: Integrate note configuration in Canvas.tsx</name>
  <files>frontend/src/components/Canvas/Canvas.tsx</files>
  <action>
Update Canvas.tsx to:

1. Import from noteColorPersistence.ts:
   ```typescript
   import { restoreNoteColor, createNoteColorListener } from './noteColorPersistence'
   ```

2. Import NoteShapeUtil from tldraw for type reference.

3. In handleMount callback, add after existing code:
   ```typescript
   // Enable aspect-locked resize for notes (square Post-it shape)
   // Per RESEARCH.md: NoteShapeUtil.options.resizeMode = 'scale'
   const noteUtil = editor.getShapeUtil('note')
   if (noteUtil && 'options' in noteUtil) {
     (noteUtil as any).options.resizeMode = 'scale'
   }

   // Restore last-used note color from localStorage
   restoreNoteColor(editor)
   ```

4. Add useEffect for note color listener:
   ```typescript
   useEffect(() => {
     if (editorRef.current) {
       const unsubscribe = createNoteColorListener(editorRef.current)
       return unsubscribe
     }
   }, []) // Empty deps - runs once after mount
   ```

Wait - the editorRef is set in handleMount, so the useEffect needs to track when editor is available. Use a state flag:

Actually, simpler approach: Start the listener directly in handleMount since we have the editor:

```typescript
const handleMount = useCallback((editor: Editor) => {
  editorRef.current = editor

  // ... existing code ...

  // Note configuration
  const noteUtil = editor.getShapeUtil('note')
  if (noteUtil && 'options' in noteUtil) {
    (noteUtil as any).options.resizeMode = 'scale'
  }
  restoreNoteColor(editor)

  // Start note color persistence listener
  // Note: This listener runs for the lifetime of the editor
  createNoteColorListener(editor)
}, [])
```

The listener returns an unsubscribe function, but since the editor lives for the component lifetime, we don't need to clean it up separately (tldraw handles cleanup on unmount).
  </action>
  <verify>
1. TypeScript compiles: `cd frontend && npx tsc --noEmit`
2. Vite builds: `cd frontend && npm run build`
  </verify>
  <done>Canvas.tsx enables note resize mode, restores note color on mount, and persists color changes to localStorage.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. TypeScript compilation passes
2. Vite production build succeeds
3. Files exist:
   - frontend/src/components/Canvas/styleConfig.ts (updated with noteFill/noteText)
   - frontend/src/components/Canvas/noteColorPersistence.ts (new)
   - frontend/src/components/Canvas/Canvas.tsx (updated with note config)
</verification>

<success_criteria>
- styleConfig.ts configures 8 sticky note colors for light and dark modes
- noteColorPersistence.ts provides save/restore/listen functions
- Canvas.tsx enables note resize and color persistence
- All code compiles without TypeScript errors
- tldraw's built-in note and text tools are available via toolbar (DefaultToolbar includes them)
</success_criteria>

<output>
After completion, create `.planning/phases/04-notes-text/04-01-SUMMARY.md`
</output>
